use Structures: all;
use StdIO: all;


#define SIZE 5

/*******************************************************************************
 * 
 * Sudkou solver in SaC.
 *
 * This program tries to solve sudokus in a straight forward manner:
 * During the solving process, we store the state of our sudoku in two
 * arrays:
 *
 * - a 9x9 matrix 'set' of integers holding the numbers put down so far.
 * - a 9x9 matrix 'opts' of 9-element boolean vectors holding the possible
 *                       options for all positions.
 *
 * As soon as we place a number ( function 'addNumber'), we update the set
 * and opts arrays accordingly.
 *
 * The solution process requires back-tracking which is implemented by
 * recursion (function 'solve'). In order to keep the amount of back-
 * tracking to a minimum, we identify those positions with a minimum of
 * options first. The function 'findMinTrues' is used to that effect.
 */

int[*], bool[*] addNumber( int i, int j, int k, int[*] set, bool[*] opts)
{
  set[i,j] = k;
  k = k-1;
  i_q = (i/SIZE)*SIZE;
  j_q = (j/SIZE)*SIZE;
  opts = with(iv)
          ([i,j,0] <= iv <= [i,j,SIZE*SIZE-1]) : false;
          ([i,0,k] <= iv <= [i,SIZE*SIZE-1,k]) : false;
          ([0,j,k] <= iv <= [SIZE*SIZE-1,j,k]) : false;
          ([i_q,j_q,k] <= iv <= [i_q+SIZE-1,j_q+SIZE-1,k]) : false;
         modarray( opts);

  return( set, opts);
}

int countTrues( bool[*] b)
{
  return( sum( toi( b)));
}

int findTrue( bool[.] b)
{
  i=0;
  while( !(b[i])) {
    i++;
  }
  return( i);
}

int, int findMinTrues( bool[*] opts)
{
  minCount = SIZE*SIZE;
  min_i = 0;
  min_j = 0;

  for( i=0; i<SIZE*SIZE; i++) {
    for( j=0; j<SIZE*SIZE; j++) {
      if( (countTrues( opts[i,j]) < minCount)
          && (0 < countTrues( opts[i,j]))) {
        minCount = countTrues( opts[i,j]);
        min_i = i;
        min_j = j;
      }
    }
  }
  return( min_i, min_j);
}

bool isStuck( int[*] set, bool[*] opts)
{
  stuck = { [i,j] -> (set[i,j] == 0) && !any( opts[i,j]) };
  return( any( stuck));
}

bool isCompleted(  int[*] set)
{
  return( all(set != 0));
}

int[*], bool[*] solve( int[*] set, bool[*] opts)
{
  while( !( isStuck( set, opts) || isCompleted( set)) ) {
    i,j = findMinTrues( opts);
    if( countTrues( opts[i,j]) == 1) {
      set, opts = addNumber( i,j, findTrue( opts[i,j]) +1  ,set,opts);
    } else {
      /**
       * here, we need to place a number without being sure that it
       * is the correct one, i.e., we may need to back-track.
       * This is achieved by storing the actual state in 'mem_set'
       * and 'mem_opts', which are used within the for-loop that
       * actually successively tries all possible values until
       * a solution is found.
       */
      mem_set = set;
      mem_opts = opts;
      for( k=0; (k<SIZE*SIZE) && (!isCompleted(set)); k++) {
        if( mem_opts[i, j, k] ) {
          set, opts = addNumber( i, j, k+1, mem_set, mem_opts);
          set, opts = solve( set, opts);
        }
      }
    }
  }
  return( set, opts);
}

int main()
{ 
  set = genarray( [SIZE*SIZE,SIZE*SIZE], 0);
  opts = genarray( [SIZE*SIZE,SIZE*SIZE,SIZE*SIZE], true);

  a = FibreScanIntArray( stdin, 2, [SIZE*SIZE,SIZE*SIZE]);

  for( i=0; i<SIZE*SIZE; i++) {
    for( j=0; j<SIZE*SIZE; j++) {
      if( a[i,j] > 0 ) {
        set, opts = addNumber( i,j, a[i,j],set,opts);
      }
    }
  }

  set, opts = solve( set, opts);
  print( set);

  return( 0);
}
