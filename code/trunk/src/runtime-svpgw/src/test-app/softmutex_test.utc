#include "snet-gwrt.utc.h"
#include "snet-gwrt.int.utc.h"

/*---*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

typedef struct {
    place        plc;
    family       fid;
    unsigned int count;

} snet_mutex_t;

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static inline family get_current_fid()
{
    uTC::ThreadInfo *cti = uTC::GetThreadInfo();
    return cti->f;
}

static thread void lock_mutex_th(
    snet_mutex_t *mutex, family fid, shared bool suspend)
{
    assert(mutex != NULL);

    if (mutex->count == 0) {
        mutex->fid = fid;
    }

    if (mutex->fid == fid) {
        mutex->count++;

        suspend = false;
        return;
    }
    
    suspend = true;
}

static thread void unlock_mutex_th(snet_mutex_t *mutex, family fid)
{
    assert(mutex != NULL);

    if (mutex->count > 0 && mutex->fid == fid) {
        mutex->count--;
    }
}

/*----------------------------------------------------------------------------*/

static bool mutex_lock(snet_mutex_t *mutex, bool try_once)
{
    if (mutex == NULL) {
        return false;
    }

    bool suspend = false;

    family lfid;
    family cfid = get_current_fid();
    
    do {
        create (lfid; mutex->plc; 0; 0; 1; 1;;)
            lock_mutex_th(mutex, cfid, suspend);

        sync (lfid);

    } while (suspend || try_once);

    return (!suspend);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

void SNetMutexInit(snet_mutex_t *mutex)
{
    mutex->count = 0;

    snet_place_specs_t plc_specs = {
        false,
        true,
        PLACE_TYPE_GENERIC,
        NULL,
        0
    };

    mutex->plc = SNetPlaceGetFromContract(SNetPlaceAlloc(&plc_specs));
}

void SNetMutexLock(snet_mutex_t *mutex)
{
    mutex_lock(mutex, false);
}

bool SNetMutexTryLock(snet_mutex_t *mutex)
{
    return mutex_lock(mutex, true);
}

void SNetMutexUnlock(snet_mutex_t *mutex)
{
    if (mutex == NULL) {
        return;
    }

    family lfid;
    family cfid = get_current_fid();

    create (lfid; mutex->plc; 0; 0; 1; 1;;) unlock_mutex_th(mutex, cfid);
    sync (lfid);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static thread void foo(
    unsigned int tid, snet_mutex_t *mutex, unsigned int test_sz)
{
    unsigned int ltid = tid;

    for (unsigned int j=0; j < test_sz; j++) {
        //SNetMutexLock(mutex);
        pthread_mutex_lock(&mutex->plc->exclusion_mutex);

        printf("FOO(%u): %u", ltid, j);
        printf("\n");

        //SNetMutexUnlock(mutex);
        pthread_mutex_unlock(&mutex->plc->exclusion_mutex);
    }
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

void softmutex_test()
{   
    family       fid0;
    family       fid1;
    snet_mutex_t mutex;

    SNetMutexInit(&mutex);

    create (fid0;; 0; 0; 1; 1;;) foo(0, &mutex, 10000);
    create (fid1;; 0; 0; 1; 1;;) foo(1, &mutex, 10000);

    sync(fid0);
    sync(fid1);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

