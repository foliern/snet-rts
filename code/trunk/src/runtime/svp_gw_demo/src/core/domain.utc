/*----------------------------------------------------------------------------*/
/*
      -------------------------------------------------------------------

              * * * * ! SVP S-Net Graph Walker Runtime ! * * * *

                  Computer Systems Architecture (CSA) Group
                            Informatics Institute
                        University Of Amsterdam  2008
                         
      -------------------------------------------------------------------

    File Name      : domain.utc

    File Type      : Code File

    ---------------------------------------

    File 
    Description    :

    Updates 
    Description    : N/A

*/
/*----------------------------------------------------------------------------*/

#include "domain.int.utc.h"
#include "basetype.int.utc.h"
#include "list.int.utc.h"
#include "graph.int.utc.h"
#include "memmng.int.utc.h"
#include "plcmng.int.utc.h"

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

struct domain_gw_info {
    bool          valid;
    family        fid;
    snet_gnode_t *gnode;

};

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Structures for the different types of domains */

typedef struct {
    place        owner_plc;
    snet_list_t *snetds;

} snet_domain_sys_t;

/*----------------------------------------------------------------------------*/

typedef struct {
    unsigned int id;
    place        owner_plc;

    snet_list_t    *gws;
    snet_gnode_t   *graph_root;
    snet_conslst_t *cons_list;
    snet_buffer_t  *out_buffer;

    snet_place_contract_t *gw_plc_cntr;

#ifdef SVPSNETGWRT_USE_KILL_HACK_FOR_OUT_BUFFER_SUSPEND
    bool   out_buf_wait_fam_exists;
    bool   out_buf_wait_fid_valid;
    family out_buf_wait_fid;

    snet_place_contract_t *out_buf_cond_plc_cntr;
#endif

} snet_domain_net_t;

/*---*/

typedef struct {
    snet_domain_type_t snetd_orig_type;
    unsigned int       snetd_orig_id;
    place              snetd_orig_plc;
    place              gw_plc;

} snet_domain_alias_t;

/*---*/

typedef struct {
    unsigned int   id;
    place          owner_plc;

    unsigned int   snetd_master_id;
    place          snetd_master_plc;

    place          gw_plc;

} snet_domain_worker_t;

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

struct domain {
    snet_domain_type_t type;

    union {
        snet_domain_sys_t    sys;
        snet_domain_net_t    net;
        snet_domain_alias_t  alias;
        snet_domain_worker_t worker;

    } data;

}; // struct domain

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Module's private static data */

/**
 * The "system" domain for the execution enviroment of the runtime (e.g. a 
 * "place", which can be computational, memory resources or both).
 */
static snet_domain_t *SYS_SNETD = NULL;

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Module's static functions */

static inline bool is_subsys_init()
{
    return (SYS_SNETD != NULL);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static inline snet_domain_t* alloc_domain()
{
    return (snet_domain_t *) SNetMemAlloc(sizeof(snet_domain_t));
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static thread void push_to_domain_list(
    snet_domain_t *snetd, shared unsigned int snetd_id)
{
    assert(snetd->type != DOMAIN_TYPE_SYS);
    assert(snetd->type != DOMAIN_TYPE_ALIAS);

    snet_domain_t *lsnetd = snetd;

    snetd_id = SNetListPushBack(SYS_SNETD->data.sys.snetds, &lsnetd);
}

/*----------------------------------------------------------------------------*/

static thread void remove_from_domain_list(snet_domain_t *snetd)
{
    assert(snetd->type != DOMAIN_TYPE_SYS);
    assert(snetd->type != DOMAIN_TYPE_ALIAS);
   
    unsigned int snetd_id = (
        snetd->type == DOMAIN_TYPE_NET ?
        snetd->data.net.id : snetd->data.worker.id);

    SNetListRemove(SYS_SNETD->data.sys.snetds, snetd_id);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static void init_net_domain(snet_domain_t *snetd)
{
    assert(snetd != NULL);

    snetd->type = DOMAIN_TYPE_NET;

    snetd->data.net.owner_plc = SNetGetMyPlace();

    snetd->data.net.gws = 
        SNetListCreate(
            sizeof(struct domain_gw_info),
            0,
            (snet_domain_t *) SNetMaskPointer(snetd));

    snetd->data.net.graph_root = NULL;
    snetd->data.net.cons_list  = SNetConsLstCreate(snetd);

    snetd->data.net.out_buffer = SNetBufCreate(
        true, 0, (snet_domain_t *) SNetMaskPointer(snetd));

    // Create and setup a mutex places for the domain's 
    // data structures.
    snet_place_specs_t mutex_plc_specs = {
        false,
        true,
        PLACE_TYPE_SNET_RT_SPEC,
        NULL
    };

    // List of GWs.
    SNetBaseTypeSetPlacesContracts(
        SNetListToBase(snetd->data.net.gws),
        NULL,
        SNetPlaceAlloc(&mutex_plc_specs),
        NULL);

    // Cons-List.
    SNetBaseTypeSetPlacesContracts(
        SNetConsLstToBase(snetd->data.net.cons_list),
        NULL,
        SNetPlaceAlloc(&mutex_plc_specs),
        NULL);

    // Output buffer.
    SNetBaseTypeSetPlacesContracts(
        SNetBufToBase(snetd->data.net.out_buffer),
        NULL, 
        SNetPlaceAlloc(&mutex_plc_specs),
        NULL);

    // For now no special place is
    // used for the GW
    snetd->data.net.gw_plc_cntr = NULL;

#ifdef SVPSNETGWRT_USE_KILL_HACK_FOR_OUT_BUFFER_SUSPEND
    snetd->data.net.out_buf_wait_fam_exists  = false;
    snetd->data.net.out_buf_wait_fid_valid   = false;
    snetd->data.net.out_buf_cond_plc_cntr = SNetPlaceAlloc(&mutex_plc_specs);
#endif

    // Add domain to system domains list. We do a "create" because
    // this operation must be done with mutual exclussion on the
    // domains list
    family fid;

    place  snetd_lst_mutex = 
        SNetBaseTypeGetMutexPlace(
            SNetListToBase(SYS_SNETD->data.sys.snetds));

    unsigned int snetd_id = 0;

    create(fid; 
        snetd_lst_mutex; 0; 0; 1; 1;;) 
            push_to_domain_list(snetd, snetd_id);

    sync(fid);

    snetd->data.net.id = snetd_id;
}

/*----------------------------------------------------------------------------*/

static void init_alias_domain(
    snet_domain_t *snetd, const snet_domain_t *snetd_orig)
{
    assert(snetd != NULL);
    assert(snetd_orig != NULL);
    assert(snetd_orig->type != DOMAIN_TYPE_SYS);

    snetd->type = DOMAIN_TYPE_ALIAS;

    switch (snetd_orig->type) {
        case DOMAIN_TYPE_NET:
            snetd->data.alias.snetd_orig_type = DOMAIN_TYPE_NET;
            snetd->data.alias.snetd_orig_id   = snetd_orig->data.net.id;
            snetd->data.alias.snetd_orig_plc  = snetd_orig->data.net.owner_plc;

            snetd->data.alias.gw_plc = (
                snetd_orig->data.net.gw_plc_cntr == NULL ?
                snetd_orig->data.net.owner_plc :
                SNetPlaceGetFromContract(snetd_orig->data.net.gw_plc_cntr));

            break;

        case DOMAIN_TYPE_ALIAS:
            snetd->data.alias = snetd_orig->data.alias;
            break;

        case DOMAIN_TYPE_WORKER:
            snetd->data.alias.snetd_orig_type = DOMAIN_TYPE_WORKER;

            snetd->data.alias.snetd_orig_id =
                snetd_orig->data.worker.snetd_master_id;

            snetd->data.alias.snetd_orig_plc =
                snetd_orig->data.worker.snetd_master_plc;

            snetd->data.alias.gw_plc = snetd_orig->data.worker.gw_plc;

            break;

        default: 
            // !!WARNING!! This should never happen!!
            //
            // Only required to silence the compiler
            // about enumeration values that are
            // not handled.
            assert(false);
            break;
    }
}

/*----------------------------------------------------------------------------*/

static void init_worker_domain(
    snet_domain_t *snetd, const snet_domain_t *snetd_master)
{
    assert(snetd != NULL);
    assert(snetd_master != NULL);
    assert(snetd_master->type != DOMAIN_TYPE_SYS);

    snetd->data.worker.owner_plc = SNetGetMyPlace();

    switch (snetd_master->type) {
        case DOMAIN_TYPE_NET:
            snetd->data.worker.
                snetd_master_id  = snetd_master->data.net.id;

            snetd->data.worker.
                snetd_master_plc = snetd_master->data.net.owner_plc;

            snetd->data.worker.gw_plc = (
                snetd_master->data.net.gw_plc_cntr == NULL ?
                snetd_master->data.net.owner_plc :
                SNetPlaceGetFromContract(snetd_master->data.net.gw_plc_cntr));

            break;

        case DOMAIN_TYPE_ALIAS:
            snetd->data.worker.snetd_master_id = 
                snetd_master->data.alias.snetd_orig_id;

            snetd->data.worker.snetd_master_plc =
                snetd_master->data.alias.snetd_orig_plc;

            snetd->data.worker.gw_plc =
                snetd_master->data.alias.gw_plc;

            break;

        case DOMAIN_TYPE_WORKER:
            snetd->data.worker.snetd_master_id = 
                snetd_master->data.worker.snetd_master_id;

            snetd->data.worker.snetd_master_plc =
                snetd_master->data.worker.snetd_master_plc;

            snetd->data.worker.gw_plc =
                snetd_master->data.worker.gw_plc;

            break;

        default: 
            // !!WARNING!! This should never happen!!
            //
            // Only required to silence the compiler
            // about enumeration values that are
            // not handled.
            assert(false);
            break;
    }

    // Add domain to system domains list. We do a "create" because
    // this operation must be done with mutual exclussion on the
    // domains list
    family fid;

    place  snetd_lst_mutex = 
        SNetBaseTypeGetMutexPlace(
            SNetListToBase(SYS_SNETD->data.sys.snetds));

    unsigned int snetd_id = 0;

    create(fid; 
        snetd_lst_mutex; 0; 0; 1; 1;;) 
            push_to_domain_list(snetd, snetd_id);

    sync(fid);

    snetd->data.worker.id = snetd_id;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static void destroy_net_domain(snet_domain_t *snetd)
{
    /**
     * !!TODO!!: Cleanup domain.
     */

    // Remove domain from system domains list. We do a "create" because
    // this operation must be done with mutual exclussion on the
    // domains list
    family fid;

    place  snetd_lst_mutex = 
        SNetBaseTypeGetMutexPlace(
            SNetListToBase(SYS_SNETD->data.sys.snetds));

    create(fid;
        snetd_lst_mutex; 0; 0; 1; 1;;) 
            remove_from_domain_list(snetd);

    sync(fid);

    SNetBufDestroy(snetd->data.net.out_buffer);
    SNetConsLstDestroy(snetd->data.net.cons_list);
    SNetListDestroy(snetd->data.net.gws);
    
    if (snetd->data.net.graph_root != NULL) {
        /**
         * !!TODO!!: Destroy Graph
         */
        SNetGNodeDestroy(snetd->data.net.graph_root, true);
    }

    if (snetd->data.net.gw_plc_cntr != NULL)
        SNetPlaceFree(snetd->data.net.gw_plc_cntr);

#ifdef SVPSNETGWRT_USE_KILL_HACK_FOR_OUT_BUFFER_SUSPEND
    if (snetd->data.net.out_buf_cond_plc_cntr != NULL)
        SNetPlaceFree(snetd->data.net.out_buf_cond_plc_cntr);
#endif 
}

/*----------------------------------------------------------------------------*/

static void destroy_alias_domain(snet_domain_t *snetd)
{
    /**
     * Nothing to do!!!
     */
}

/*----------------------------------------------------------------------------*/

static void destroy_worker_domain(snet_domain_t *snetd)
{
    // Remove domain from system domains list. We do a "create" because
    // this operation must be done with mutual exclussion on the
    // domains list
    family fid;

    place  snetd_lst_mutex = 
        SNetBaseTypeGetMutexPlace(
            SNetListToBase(SYS_SNETD->data.sys.snetds));

    create(fid;
        snetd_lst_mutex; 0; 0; 1; 1;;) 
            remove_from_domain_list(snetd);

    sync(fid);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Sub-system initialization related functions (internal only) */

void SNetDomainSubSystemInit()
{
    // Initialization of the sub-system means 
    // the initialization of the "system" domain.
    assert(!is_subsys_init());

    SYS_SNETD = (snet_domain_t *) SNetMemAlloc(sizeof(snet_domain_t));

    SYS_SNETD->type = DOMAIN_TYPE_SYS;

    SYS_SNETD->data.sys.owner_plc = SNetGetMyPlace();

    SYS_SNETD->data.sys.snetds = 
        SNetListCreate(sizeof(snet_domain_t *), 0, SYS_SNETD);

    // Create and set required mutex places
    snet_place_specs_t mutex_plc_specs = {
        false,
        true,
        PLACE_TYPE_SNET_RT_SPEC,
        NULL
    };
        
    SNetBaseTypeSetPlacesContracts(
        SNetListToBase(SYS_SNETD->data.sys.snetds),
        NULL, 
        SNetPlaceAlloc(&mutex_plc_specs),
        NULL);
}

/*----------------------------------------------------------------------------*/

void SNetDomainSubSystemDestroy()
{
    assert(is_subsys_init());

    // Destroy all domain not destroyed yet.
    for (unsigned int it = SNetListBegin(SYS_SNETD->data.sys.snetds);
         it != 0; it = SNetListItemGetNext(SYS_SNETD->data.sys.snetds, it)) {

        snet_domain_t *snetd = NULL; 

        SNetListItemGetValue(SYS_SNETD->data.sys.snetds, it, &snetd);
        SNetDomainDestroy((snet_domain_t *) SNetMaskPointer(snetd));
    }

    SNetListDestroy(SYS_SNETD->data.sys.snetds);
    SNetMemFree(SYS_SNETD);

    // Reset this to NULL to indicate that the
    // sub-system is not initialized any more.
    SYS_SNETD = NULL;
}

/*----------------------------------------------------------------------------*/

const snet_domain_t* SNetDomainGetSystem()
{
    return SYS_SNETD;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Public functions used by both the runtime and user code */

snet_domain_t* SNetDomainCreate()
{
    assert(is_subsys_init());

    snet_domain_t *snetd = alloc_domain();
    
    init_net_domain(snetd);

    return (snet_domain_t *) SNetMaskPointer(snetd);
}

/*----------------------------------------------------------------------------*/

void SNetDomainDestroy(snet_domain_t *snetd)
{
    assert(snetd != NULL);

    snetd = (snet_domain_t *) SNetUnmaskPointer(snetd);

    assert(snetd->type != DOMAIN_TYPE_SYS);

    switch (snetd->type) {
        case DOMAIN_TYPE_NET:
            destroy_net_domain(snetd);
            break;

        case DOMAIN_TYPE_ALIAS:
            destroy_alias_domain(snetd);
            break;

        case DOMAIN_TYPE_WORKER:
            destroy_worker_domain(snetd);
            break;

        default: 
            // !!WARNING!! This should never happen!!
            //
            // Only required to silence the compiler
            // about enumeration values that are
            // not handled.
            assert(false);
            break;
    }

    SNetMemFree(snetd);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

void SNetDomainSetGraph(snet_domain_t *snetd, snet_gnode_t *groot)
{
    assert(groot  != NULL);
    assert(snetd != NULL);

    if (snetd == NULL || groot == NULL) {
        return;
    }

    snetd = (snet_domain_t *) SNetUnmaskPointer(snetd);
    groot = (snet_gnode_t *)  SNetUnmaskPointer(groot);

    assert(snetd->type == DOMAIN_TYPE_NET);
    assert(snetd->data.net.graph_root == NULL);

    if (snetd->data.net.graph_root != NULL) {
        return;
    }

    assert(SNetDomainIsSame(
        snetd, SNetBaseTypeGetDomain(SNetGNodeToBase(groot))));

    if (! SNetDomainIsSame(
        snetd, SNetBaseTypeGetDomain(SNetGNodeToBase(groot)))) {

        return;
    }

    snetd->data.net.graph_root = groot;

    SNetGraphEnumerate(snetd->data.net.graph_root);
}

/*----------------------------------------------------------------------------*/

// void SNetDomainReplaceGraphNode(
//     snet_domain_t *snetd, const snet_ginx_t *inx, const snet_gnode_t *n)
// {
//     /**
//      * Not implemented yet
//      */
// }

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Private functions only used within the runtime */

snet_domain_t*
SNetDomainCreateAlias(const snet_domain_t *snetd_orig)
{
    snet_domain_t *snetd = alloc_domain();
    
    init_alias_domain(snetd, snetd_orig);

    return (snet_domain_t *) SNetMaskPointer(snetd);
}

snet_domain_t*
SNetDomainCreateWorker(const snet_domain_t *snetd_master)
{
    snet_domain_t *snetd = alloc_domain();
    
    init_worker_domain(snetd, snetd_master);

    return (snet_domain_t *) SNetMaskPointer(snetd);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

bool SNetDomainIsSame(
    const snet_domain_t *snetd1, const snet_domain_t *snetd2)
{
    assert(snetd1 != NULL);
    assert(snetd2 != NULL);

    assert(snetd1->type != DOMAIN_TYPE_SYS);
    assert(snetd2->type != DOMAIN_TYPE_SYS);

    if (snetd1 == snetd2) {
        return true;
    }

    if (snetd1->type == DOMAIN_TYPE_NET &&
        snetd2->type == DOMAIN_TYPE_NET) {

        return false;
    }

    const place plc1 = (
        snetd1->type == DOMAIN_TYPE_NET ?
        snetd1->data.net.owner_plc : (
            snetd1->type == DOMAIN_TYPE_ALIAS ?
            snetd1->data.alias.snetd_orig_plc :
            snetd1->data.worker.snetd_master_plc));
            
    const place plc2 = (
        snetd2->type == DOMAIN_TYPE_NET ?
        snetd2->data.net.owner_plc : (
            snetd2->type == DOMAIN_TYPE_ALIAS ?
            snetd2->data.alias.snetd_orig_plc :
            snetd2->data.worker.snetd_master_plc));

    const unsigned int id1 = (
        snetd1->type == DOMAIN_TYPE_NET ?
        snetd1->data.net.id : (
            snetd1->type == DOMAIN_TYPE_ALIAS ?
            snetd1->data.alias.snetd_orig_id  :
            snetd1->data.worker.snetd_master_id));
            
    const unsigned int id2 = (
        snetd2->type == DOMAIN_TYPE_NET ?
        snetd2->data.net.id : (
            snetd2->type == DOMAIN_TYPE_ALIAS ?
            snetd2->data.alias.snetd_orig_id  :
            snetd2->data.worker.snetd_master_id));

    return (plc1 == plc2 && id1 == id2);
}

/*----------------------------------------------------------------------------*/

snet_domain_type_t
SNetDomainGetType(const snet_domain_t *snetd)
{
    assert(snetd != NULL);
    return snetd->type;
}

snet_conslst_t*
SNetDomainGetConsList(const snet_domain_t *snetd)
{
    assert(snetd != NULL);
    assert(snetd->type == DOMAIN_TYPE_NET);
    
    return snetd->data.net.cons_list;
}

snet_gnode_t*
SNetDomainGetGraphRoot(const snet_domain_t *snetd)
{
    assert(snetd != NULL);
    assert(snetd->type == DOMAIN_TYPE_NET);
    
    return snetd->data.net.graph_root;
}

snet_buffer_t*
SNetDomainGetOutBuffer(const snet_domain_t *snetd)
{
    assert(snetd != NULL);
    assert(snetd->type == DOMAIN_TYPE_NET);

    return snetd->data.net.out_buffer;
}

/*----------------------------------------------------------------------------*/

place SNetDomainGetGWPlace(const snet_domain_t *snetd)
{
    assert(snetd != NULL); 
    assert(snetd->type != DOMAIN_TYPE_SYS);

    switch (snetd->type) {
        case DOMAIN_TYPE_NET:
            if (snetd->data.net.gw_plc_cntr != NULL)
                return SNetPlaceGetFromContract(snetd->data.net.gw_plc_cntr);

            break;
        
        case DOMAIN_TYPE_ALIAS:
            return snetd->data.alias.gw_plc;

        case DOMAIN_TYPE_WORKER:
            return snetd->data.worker.gw_plc;

        default: 
            // !!WARNING!! This should never happen!!
            //
            // Only required to silence the compiler
            // about enumeration values that are
            // not handled.
            assert(false);
            break;
    }

    return SNetGetMyPlace();
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

#ifdef SVPSNETGWRT_USE_KILL_HACK_FOR_OUT_BUFFER_SUSPEND

void SNetDomainWakeupOutBufferWaitFamily(snet_domain_t *snetd)
{
    assert(snetd != NULL); 
    assert(snetd->type == DOMAIN_TYPE_NET);

    if (!snetd->data.net.out_buf_wait_fam_exists) {
        return;
    }

    while (!snetd->data.net.out_buf_wait_fid_valid);
    kill (snetd->data.net.out_buf_wait_fid);
    
    snetd->data.net.out_buf_wait_fam_exists = false;
    snetd->data.net.out_buf_wait_fid_valid  = false;
}

void SNetDomainSetOutBufferWaitFID(snet_domain_t *snetd, family fid)
{
    assert(snetd != NULL); 
    assert(snetd->type == DOMAIN_TYPE_NET);

    snetd->data.net.out_buf_wait_fid       = fid;
    snetd->data.net.out_buf_wait_fid_valid = true;
}

place SNetDomainGetOutBufferCondPlace(snet_domain_t *snetd)
{
    assert(snetd != NULL); 
    assert(snetd->type == DOMAIN_TYPE_NET);

    snetd->data.net.out_buf_wait_fam_exists = true;

    return SNetPlaceGetFromContract(snetd->data.net.out_buf_cond_plc_cntr);
}

#endif // SVPSNETGWRT_USE_KILL_HACK_FOR_OUT_BUFFER_SUSPEND

/*------------------------------END OF FILE ----------------------------------*/
/*----------------------------------------------------------------------------*/

