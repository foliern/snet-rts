/*----------------------------------------------------------------------------*/
/*
      -------------------------------------------------------------------

           * * * * ! SVP S-Net Graph Walker Runtime (demo) ! * * * *

                   Computer Systems Architecture (CSA) Group
                             Informatics Institute
                         University Of Amsterdam  2008
                         
      -------------------------------------------------------------------

    File Name      : gw.utc

    File Type      : Code File

    ---------------------------------------

    File 
    Description    :

    Updates 
    Description    : N/A

*/
/*----------------------------------------------------------------------------*/

#include "gw.int.utc.h"
#include "graphstructs.int.utc.h"

#include "buffer.int.utc.h"
#include "list.int.utc.h"
#include "memmng.int.utc.h"

/*---*/

#include "snet.utc.h"

/*----------------------------------------------------------------------------*/

#define CNODE_FLAG_DISPOSABLE                   0x01
#define CNODE_FLAG_INFIMUM_CHANGED              0x02
#define CNODE_FLAG_ON_STATE_CHANGE_PROP_INFIMUM 0x04

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

typedef enum {
    CNODE_SET_FLAGS_NEVER,
    CNODE_SET_FLAGS_ALWAYS,
    CNODE_SET_FLAGS_IF_COND_TRUE,
    CNODE_SET_FLAGS_IF_COND_FALSE

} snet_cnode_flags_set_mode_t;

/*----------------------------------------------------------------------------*/

static bool
conslst_node_set_state(
    snet_conslst_node_t *n, snet_conslst_node_state_t state);

/*---*/

static bool
conslst_node_set_state_ts(
    snet_conslst_node_t *n, snet_conslst_node_state_t state);

static bool
conslst_node_check_for_state_ts(
    snet_conslst_node_t *n,
    snet_conslst_node_state_t state,
    unsigned int flags_to_set, snet_cnode_flags_set_mode_t flags_set_mode);

/*---*/

static void 
propagate_infimum(
    unsigned int create_local,
    snet_conslst_node_t *cnode, snet_gnode_t *synccell_gnode);

static thread void
move_cons_node_to_gnode(snet_conslst_node_t *cnode, snet_gnode_t *gnode);

/*---*/

static void
output_waitting_records(
    unsigned int create_local, 
    snet_gnode_t *synccell_gnode,
    snet_conslst_node_t *start_consnode);

static void
prepare_handle_for_moving(
    snet_handle_t *hnd,
    bool new_handle, snet_record_t *fli_rec);

static thread void advance_handle(snet_handle_t *hnd);

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Cons-Node state management functions */

static inline void 
conslst_node_set_flag(
    snet_conslst_node_t *cnode, unsigned int flag)
{
    SNetConsLstNodeSetFlags(cnode, flag | SNetConsLstNodeGetFlags(cnode));
}

static inline void 
conslst_node_reset_flag(
    snet_conslst_node_t *cnode, unsigned int flag)
{
    SNetConsLstNodeSetFlags(cnode, (~flag) & SNetConsLstNodeGetFlags(cnode));
}

/*----------------------------------------------------------------------------*/

static bool 
conslst_node_set_state(
    snet_conslst_node_t *n, snet_conslst_node_state_t state)
{
    SNetConsLstNodeSetState(n, state);

    if (state == CONS_NODE_STATE_WALKING) {
        return false;
    }
    
    return ((SNetConsLstNodeGetFlags(n) &
         CNODE_FLAG_ON_STATE_CHANGE_PROP_INFIMUM) > 0); 
}

static bool
conslst_node_check_for_state(
    snet_conslst_node_t *n,
    snet_conslst_node_state_t state,
    unsigned int flags_to_set, snet_cnode_flags_set_mode_t flags_set_mode)
{
    bool ret_val = (state == SNetConsLstNodeGetState(n));

    switch (flags_set_mode) {
        case CNODE_SET_FLAGS_NEVER:
            break;

        case CNODE_SET_FLAGS_ALWAYS:
            conslst_node_set_flag(n, flags_to_set);
            break;

        case CNODE_SET_FLAGS_IF_COND_TRUE:
            if (ret_val)
                conslst_node_set_flag(n, flags_to_set);

            break;

        case CNODE_SET_FLAGS_IF_COND_FALSE:
            if (!ret_val)
                conslst_node_set_flag(n, flags_to_set);

            break;
    }

    return ret_val;
}

/*----------------------------------------------------------------------------*/

static thread void 
conslst_node_set_state_th(
    snet_conslst_node_t *n,
    snet_conslst_node_state_t state, shared bool prop_infimum)
{
    prop_infimum = conslst_node_set_state(n, state);
}

static thread void
conslst_node_check_for_state_th(
    snet_conslst_node_t *n,
    snet_conslst_node_state_t state, 
    unsigned int flags_to_set,
    snet_cnode_flags_set_mode_t flags_set_mode, shared bool res)
{
    res = conslst_node_check_for_state(
        n, state, flags_to_set, flags_set_mode);
}

/*----------------------------------------------------------------------------*/

static inline bool
conslst_node_set_state_ts(
    snet_conslst_node_t *n, snet_conslst_node_state_t state)
{
    family fid;
    bool   prop_infimum = false;

    place  node_mutex_plc = 
        SNetBaseTypeGetMutexPlace(SNetConsLstNodeToBase(n));
    
    create (
        fid; 
        node_mutex_plc; 0; 0; 1; 1;;) 
            conslst_node_set_state_th(n, state, prop_infimum);

    sync(fid);
    return(prop_infimum);
}

static inline bool
conslst_node_check_for_state_ts(
    snet_conslst_node_t *n,
    snet_conslst_node_state_t state,
    unsigned int flags_to_set, snet_cnode_flags_set_mode_t flags_set_mode)
{
    family fid;
    bool   res = false;

    place  node_mutex_plc = 
        SNetBaseTypeGetMutexPlace(SNetConsLstNodeToBase(n));

    create (
        fid; 
        node_mutex_plc; 0; 0; 1; 1;;) 
            conslst_node_check_for_state_th(
                n, state, flags_to_set, flags_set_mode, res);

    sync(fid);
    return(res);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Handler functions for graph nodes */

static bool gnode_hnd_box(snet_gnode_t *gnode, snet_handle_t *hnd)
{
    assert(gnode->type == GRAPH_NODE_TYPE_BOX);

    snet_box_gnode_t *box_gnode = gnode->data.normal->entity.box;

    if (box_gnode->func == NULL) {
        return true;
    }

    if ((*box_gnode->func)((snet_handle_t *) SNetMaskPointer(hnd)) != 0) {
        const char *ginx_str =
            SNetGInxToString(gnode->data.normal->inx, NULL);

        SNetReportError(SNET_ERR_BOX, ginx_str);
        SNetMemFree((void *) ginx_str);
        SNetOnError();
    }

    if (SNetHndGetOutRecord(hnd) == NULL) {
        // The box did not emmit any
        // records. Cleanup and return false
        // so that this GW instance terminates.

        // First destroy the input record.
        snet_record_t *rec = SNetHndGetConsNodeRecord(hnd);

        // Because no fields are forwarded anywhere the 
        // record's dispose mode must be set to ALL in order
        // to cleanup everything.
        if (SNetRecGetDataDisposeMode(rec) != REC_DATA_DISPOSE_MODE_NONE) {
            SNetRecSetDataDisposeMode(rec, REC_DATA_DISPOSE_MODE_ALL);
        }

        SNetRecDestroy(rec);

        // Set the cons-node's record to NULL marking it as 
        // a "null node" which will make the graph walking function
        // to move the node at the end of the graph.
        SNetConsLstNodeSetRecord(SNetHndGetConsNode(hnd), NULL);

        return false;
    }
    
    // The box emmited records. This GW instance
    // will keep running and handling the last emitted
    // record. For the others (if any) new GW instances have
    // already been created by "SNetOut()".    
    if (SNetHndGetOutRecordsCount(hnd) > 1)
        prepare_handle_for_moving(hnd, false, NULL);
    else
        prepare_handle_for_moving(hnd, false, SNetHndGetConsNodeRecord(hnd));

    return true;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
        
static snet_synccell_state_t*
get_synccell_state(
    snet_gnode_t *gnode,
    snet_conslst_node_t *cnode, bool suspended_cnode)
{
    snet_synccell_gnode_t *sync_gnode = gnode->data.normal->entity.synccell;

    // First search the synccell's list of states to find which one to
    // use or whether there is a need for a new one.
    snet_ginx_t *cnode_dyn_inx = SNetConsLstNodeGetDynGInx(cnode);

    snet_ginx_t *cnode_inx = (
        cnode_dyn_inx != NULL ? 
        cnode_dyn_inx : gnode->data.normal->inx);

    snet_synccell_state_t *state = NULL;

    for (unsigned int it = SNetListBegin(sync_gnode->states); 
         it != 0; it = SNetListItemGetNext(sync_gnode->states, it)) {
        
        snet_synccell_state_t *ith_state =
            (snet_synccell_state_t *) 
                SNetListItemGetValueByRef(sync_gnode->states, it);

        if (SNetGInxCompare(
            ith_state->inx, cnode_inx) == GRAPH_INX_CMP_RES_EQUAL) {

            state = ith_state;
            break;
        }
    }

    if (state != NULL || suspended_cnode) {
        return state;
    }

    // No state found; the list of indexes of identity states must
    // now be searched. If a matching index is found there then it is
    // the case of an identity synccell thus we return NULL so that 
    // the record moves on. If not then a new synccell state must be
    // created as this would be the case for a "fresh" synccell.
    for (unsigned int it = SNetListBegin(sync_gnode->ident_states_inxs); 
         it != 0;
         it  = SNetListItemGetNext(sync_gnode->ident_states_inxs, it)) {
        
        snet_ginx_t *ith_ginx =
            (snet_ginx_t *) 
                SNetListItemGetValueByRef(sync_gnode->ident_states_inxs, it);

        if (SNetGInxCompare(ith_ginx, cnode_inx) == GRAPH_INX_CMP_RES_EQUAL) {
            return NULL;
        }
    }

    // It is not an identity synccell but a "fresh" one!! 
    // A new state must be created.
    return SNetSyncCellGNodeAddState(gnode, cnode_inx);
}

/*----------------------------------------------------------------------------*/

static bool
suspend_handle_in_synccell(
    snet_handle_t *hnd,
    snet_synccell_state_t *state, unsigned int matched_pattern)
{
    bool suspend_hnd = true;

    snet_handle_t *mhnd = state->mhnds[matched_pattern];

    if (mhnd != NULL) {
        switch (SNetGInxCompare(
            SNetConsLstNodeGetOrdGInx(SNetHndGetConsNode(hnd)),
            SNetConsLstNodeGetOrdGInx(SNetHndGetConsNode(mhnd)))) {

            case GRAPH_INX_CMP_RES_LESS:
                break;
                
            case GRAPH_INX_CMP_RES_GREATER:
                suspend_hnd = false;
                break;

            case GRAPH_INX_CMP_RES_EQUAL:
            case GRAPH_INX_CMP_RES_UNDEFINED:
                //!!NOTE!!: This should never happen. If it does
                // then there are bugs in the indexing of cons-nodes
                // as they enter the cons-list.
                SNetReportError(
                    SNET_ERR_UNEXPECTED,
                    "comparison of record order indexes "
                    "yielded an unexpected / invalid result");

                SNetOnError();
                break;
        }
    }

    if (suspend_hnd) {
        state->mhnds[matched_pattern] = hnd;

        if (mhnd != NULL) {
            conslst_node_set_state_ts(
                SNetHndGetConsNode(mhnd), CONS_NODE_STATE_WALKING);

            family fid;
            create<nosync> (fid;; 0; 0; 1; 1;;) advance_handle(mhnd);
        }
    }
       
    return suspend_hnd;
}

/*----------------------------------------------------------------------------*/

static void 
synccell_output(
    snet_gnode_t *gnode,
    snet_synccell_state_t *state,
    snet_handle_t *hnd, snet_conslst_node_t *ccnode)
{
    unsigned int patterns_cnt = 
        SNetTencTypeGetVariantsCount(
            gnode->data.normal->entity.synccell->patterns);

    assert(patterns_cnt > 0);

    // First find the last in stream order that matched.
    snet_handle_t *last_matched_hnd = state->mhnds[0];

    for (unsigned int i=1; i < patterns_cnt; i++) {
        switch (SNetGInxCompare(
            SNetConsLstNodeGetOrdGInx(SNetHndGetConsNode(last_matched_hnd)),
            SNetConsLstNodeGetOrdGInx(SNetHndGetConsNode(state->mhnds[i])))) {

            case GRAPH_INX_CMP_RES_LESS:
                break;
                
            case GRAPH_INX_CMP_RES_GREATER:
                last_matched_hnd = state->mhnds[i];
                break;

            case GRAPH_INX_CMP_RES_EQUAL:
            case GRAPH_INX_CMP_RES_UNDEFINED:
                //!!NOTE!!: This should never happen. If it does
                // then there are bugs in the indexing of cons-nodes
                // as they enter the cons-list.
                SNetReportError(
                    SNET_ERR_UNEXPECTED,
                    "comparison of record order indexes "
                    "yielded an unexpected / invalid result");

                SNetOnError();
                break;
        }
    }

    assert(last_matched_hnd != NULL);

    family fid;

    snet_conslst_node_t *last_cnode = SNetHndGetConsNode(last_matched_hnd);
    snet_record_t       *last_rec   = SNetConsLstNodeGetRecord(last_cnode);

    // Merge the records into the last one matched!
    // At the same time destroy the other records, handles
    // and make the associated cons-nodes NULL nodes.
    for (unsigned int i=0; i < patterns_cnt; i++) {
        if (state->mhnds[i] == last_matched_hnd) {
            continue;
        }

        snet_conslst_node_t *cnode = SNetHndGetConsNode(state->mhnds[i]);
        snet_record_t       *rec   = SNetConsLstNodeGetRecord(cnode);

        /**
         * !!TODO!!: Merge the records.
         */
        
        // That handle / cons-node / record might have matched
        // more than one patterns. So it cannot be processed any
        // further here (e.g. become NULL, destroyed, etc) if this 
        // is not the last pattern it matched.
        bool matches_more = false;

        for (unsigned int j = i + 1; j < patterns_cnt; j++) {
            if (state->mhnds[i] == state->mhnds[j]) {
                matches_more = true;
                break;
            }
        }
        
        if (matches_more) {
            continue;
        }

        // Make the cons-node a "NULL" node and it must
        // be "moved" at the "end" of the graph.
        SNetConsLstNodeSetRecord(cnode, NULL);

        if (ccnode != cnode) {
            conslst_node_set_state_ts(
                cnode, CONS_NODE_STATE_WALKING);

            place  cnode_mutex_plc = 
                SNetBaseTypeGetMutexPlace(
                    SNetConsLstNodeToBaseConst(cnode));

            create (fid; cnode_mutex_plc; 0; 0; 1; 1;;)
                move_cons_node_to_gnode(cnode, (snet_gnode_t *) NULL);

        } else {
            conslst_node_set_state(
                cnode, CONS_NODE_STATE_WALKING);

            create (fid;; 0; 0; 1; 1;;)
                move_cons_node_to_gnode(cnode, (snet_gnode_t *) NULL);
        }

        sync(fid);

        // Also do some output in case the cons-node is at the
        // head of the list (which means that there is none to
        // remove it).
        output_waitting_records((ccnode == cnode ? 1 : 0), gnode, cnode);

        // Destroy the record and the handle. The latter only if it
        // is not the one given in the argument "hnd" because if this
        // is a valid it will be reused!
        SNetRecDestroy(rec);        

        if (state->mhnds[i] != hnd)
            SNetHndDestroy(state->mhnds[i]);
    }

    // At this point the state of the synchrocell can be destroyed
    // and this incarnation of the synchrocell to become the identity.
    // All this is done by the function SNetSyncCellGNodeRemoveState().
    SNetSyncCellGNodeRemoveState(gnode, state->id, true);

    // The state of the cons-node of the last matched
    // record needs to be set to WALKING.
    if (ccnode == last_cnode)
        conslst_node_set_state(last_cnode, CONS_NODE_STATE_WALKING);
    else
        conslst_node_set_state_ts(last_cnode, CONS_NODE_STATE_WALKING);

    // If the argument "hnd" is not NULL then we arrived in this
    // function from a synchro-cell graph-node "handler" function.
    // In this case the "handle" will be associated with the cons-node
    // of the last match so the GW instance will continue with that
    // cons-node. If it is not NULL it means we arrived here from a GW
    // instance doing the infimum propagation. In this case a new GW
    // instance is required.
    if (hnd != NULL) {
        if (hnd != last_matched_hnd) {
            SNetHndSetConsNode(hnd, last_cnode);
            SNetHndDestroy(last_matched_hnd);
        }

        return;
    }

    create<nosync> (fid;; 0; 0; 1; 1;;) advance_handle(last_matched_hnd);    
}

/*----------------------------------------------------------------------------*/

static bool 
try_synccell_output(
    snet_gnode_t *gnode,
    snet_synccell_state_t *state,
    snet_handle_t *hnd, snet_conslst_node_t *ccnode)
{
    assert(gnode != NULL);
    assert(state != NULL);

    bool can_output = false;

    unsigned int patterns_cnt = 
        SNetTencTypeGetVariantsCount(
            gnode->data.normal->entity.synccell->patterns);

    if (state->mpcnt < patterns_cnt) {
        return false;
    }

    //printf("SYNC-OUT CHECK!!!\n");

    if (hnd != NULL) {
        snet_ginx_t *infimum = 
            SNetConsLstNodeGetMinGInx(SNetHndGetConsNode(hnd));

        switch(SNetGInxCompareEx(infimum, state->inx)) {
            case GRAPH_INX_CMP_RES_LESS:
                return false;
                
            case GRAPH_INX_CMP_RES_GREATER:
                can_output = true;
                break;

            case GRAPH_INX_CMP_RES_UNDEFINED:
            case GRAPH_INX_CMP_RES_EQUAL:
                break;
        }
    }

    for (unsigned int i=0; i < patterns_cnt; i++) {
        assert(state->mhnds[i] != NULL);

        snet_ginx_t *infimum = 
            SNetConsLstNodeGetMinGInx(
                SNetHndGetConsNode(state->mhnds[i]));

        const char *infimum_str = SNetGInxToString(infimum, NULL);
        const char *state_inx_str = SNetGInxToString(state->inx, NULL);

        //printf("BBBBBBBBBBB::%u => %s  :: %s\n", i, infimum_str, state_inx_str);

        if (state->mhnds[i] == hnd) {
            continue;
        }

        if (infimum_str != NULL)
            SNetMemFree((void *) infimum_str);

        if (state_inx_str != NULL)
            SNetMemFree((void *) state_inx_str);

        switch (SNetGInxCompareEx(infimum, state->inx)) {
            case GRAPH_INX_CMP_RES_LESS:
                return false;
                
            case GRAPH_INX_CMP_RES_GREATER:
                can_output = true;
                break;

            case GRAPH_INX_CMP_RES_UNDEFINED:
            case GRAPH_INX_CMP_RES_EQUAL:
                break;
        }
    }

    if (can_output) {
        //printf("SYNC-CELL OUT!!!!\n");
        synccell_output(gnode, state, hnd, ccnode);
    }

    return can_output;
}

static thread void
try_synccell_output_th(snet_gnode_t *gnode, snet_conslst_node_t *cnode)
{
    snet_synccell_state_t *sync_state = 
        get_synccell_state(gnode, cnode, true);

    if (sync_state != NULL)
        try_synccell_output(gnode, sync_state, NULL, cnode);
}

/*----------------------------------------------------------------------------*/

static thread void
gnode_hnd_synccell_ts(
    snet_gnode_t  *gnode,
    snet_handle_t *hnd,
    shared bool suspended, shared bool prop_infimum)
{
    snet_conslst_node_t   *cnode      = SNetHndGetConsNode(hnd);
    snet_synccell_gnode_t *sync_gnode = gnode->data.normal->entity.synccell;

    // Find the correct or create new
    // synchro-cell state.
    snet_synccell_state_t *state =
        get_synccell_state(gnode, cnode, false);

    // If no state is returned by get_synccell_state() it means
    // that the synchro-cell is dead.
    if (state == NULL) {
        suspended    = true;
        prop_infimum = false;

        return;
    }

    // OK we have an "active" synchro-cell! We must now see whether
    // the record is a candidate of synchronization starting with 
    // whether it matches any of the patterns!
    unsigned int matched_patterns_cnt = 0;

    unsigned int patterns_cnt = 
        SNetTencTypeGetVariantsCount(sync_gnode->patterns);

    snet_record_t          *rec  = SNetConsLstNodeGetRecord(cnode);
    snet_variantencoding_t *venc = SNetRecGetVariantEncoding(rec);

    for (unsigned int i=0; i < patterns_cnt; i++) {
        if (state->mhnds[i] != NULL) {
            continue;
        }

        if (sync_gnode->guards != NULL) {
            const snet_expr_t *guard =
                SNetEListGetExpr(sync_gnode->guards, i);

            if (guard != NULL && !SNetEEvaluateBool(guard, rec)) {
                continue;
            }
        }

        bool matched_ident = false;

        int match_cnt = SNetTencVariantsMatch(
            venc, 
            SNetTencTypeGetVariant(sync_gnode->patterns, i), &matched_ident);

        if (match_cnt > 0 || (match_cnt == 0 && matched_ident)) {
            // Matched a pattern
            if (suspend_handle_in_synccell(hnd, state, i)) {
                matched_patterns_cnt++;
            }
        }
    }

    if (state->mpcnt < patterns_cnt) {
        state->mpcnt += matched_patterns_cnt;

        if (state->mpcnt > patterns_cnt) {
            state->mpcnt = patterns_cnt;
        }
    }

    if (matched_patterns_cnt > 0 &&
        !try_synccell_output(gnode, state, hnd, NULL)) {

        // The state of the cons-node associated with the
        // handle must be set to WAIT_SYNC.
        suspended = true;

        prop_infimum = 
            conslst_node_set_state_ts(
                cnode, CONS_NODE_STATE_WAIT_SYNC);

        return;
    }

    suspended    = false;
    prop_infimum = false;
}

/*----------------------------------------------------------------------------*/

static bool gnode_hnd_synccell(snet_gnode_t *gnode, snet_handle_t *hnd)
{
    assert(gnode->type == GRAPH_NODE_TYPE_SYNC);

    bool suspended    = false;
    bool prop_infimum = false;

    family fid;
    place  gnode_mutex_plc = 
        SNetBaseTypeGetMutexPlace(SNetGNodeToBaseConst(gnode));

    create (fid; gnode_mutex_plc; 0; 0; 1; 1;;) 
        gnode_hnd_synccell_ts(gnode, hnd, suspended, prop_infimum);

    sync(fid);

    if (prop_infimum)
        propagate_infimum(0, SNetHndGetConsNode(hnd), gnode);

    return (!suspended);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static bool gnode_hnd_filter(snet_gnode_t *gnode, snet_handle_t *hnd)
{
    assert(gnode->type == GRAPH_NODE_TYPE_FILTER);

    const char *ginx_str = SNetGInxToString(gnode->data.normal->inx, NULL);

    SNetReportWarning(
        SNET_WRN_IGNORED_ENTITY,
        "filter box", ginx_str, "not supported yet");

    SNetMemFree((void *) ginx_str);
    SNetOnWarning();

    return true;
}

/*----------------------------------------------------------------------------*/

static snet_gnode_t*
gnode_walk_hnd_filter(snet_gnode_t *gnode, snet_handle_t *hnd)
{
    assert(gnode->type == GRAPH_NODE_TYPE_FILTER);
    return NULL;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static snet_gnode_t*
gnode_walk_hnd_parallel(snet_gnode_t *gnode, snet_handle_t *hnd)
{
    assert(gnode->type == GRAPH_NODE_TYPE_COMB_PARALLEL);

    snet_parallel_gnode_t *par_gnode = gnode->data.normal->entity.parallel;

    if (par_gnode->branches_cnt == 0) {
        return NULL;
    }

    unsigned int best_match_cnt = 0;
    unsigned int equally_matched_branches_cnt = 0;

    snet_variantencoding_t *rec_venc =
        SNetRecGetVariantEncoding(SNetHndGetConsNodeRecord(hnd));
   
    snet_par_comb_branch_t *sel_branch = NULL;

    for (unsigned int i=0; i < par_gnode->branches_cnt; i++) {
        snet_par_comb_branch_t *branch = par_gnode->branches + i;

        bool matched_ident = false;

        int  match_cnt = 
            SNetTencVariantMatchesType(
                rec_venc, branch->type, NULL, &matched_ident);

        if (match_cnt <= 0 && !matched_ident) {
            continue;
        }

        if ((unsigned int) match_cnt > best_match_cnt || sel_branch == NULL) {
            sel_branch     = branch;
            best_match_cnt = (unsigned int) match_cnt;

        } else if ((unsigned int) match_cnt == best_match_cnt) {        
            equally_matched_branches_cnt++;

            if (branch->taken_cnt < sel_branch->taken_cnt) {
                sel_branch     = branch;
                best_match_cnt = (unsigned int) match_cnt;
            }
        }    
    }

    if (sel_branch == NULL) { 
        const char *ginx_str = 
            SNetGInxToString(gnode->data.normal->inx, NULL);

        SNetReportError(
            SNET_ERR_TYPE_ERROR,
            "parallel combinator", ginx_str);

        SNetMemFree((void *) ginx_str);
        SNetOnError();
    }

    if (equally_matched_branches_cnt > 1) {
        sel_branch->taken_cnt++;
    }

    return sel_branch->groot;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static bool test_star_exit_cond(
    const snet_gnode_t *gnode, const snet_record_t *rec)
{
    const snet_star_gnode_t *star_gnode = gnode->data.normal->entity.star;

    if (star_gnode->type == NULL) {
        // Star with no exit patterns
        // (i.e. infinite star).

#if SVPSNETGWRT_DEBUG > 2
        const char *ginx_str =
            SNetGInxToString(gnode->data.normal->inx, NULL);
        
        SNetReportWarningCustom(
            "Infinite 'star' found at index %s", ginx_str);

        SNetMemFree((void *) ginx_str);
        SNetOnWarning();
#endif

        return false;
    }

    unsigned int variants_cnt = 
        SNetTencTypeGetVariantsCount(star_gnode->type);

    snet_variantencoding_t *venc = SNetRecGetVariantEncoding(rec);

    for (unsigned int i=0; i < variants_cnt; i++) {
        if (star_gnode->guards != NULL) {
            const snet_expr_t *guard =
                SNetEListGetExpr(star_gnode->guards, i);

            if (guard != NULL && !SNetEEvaluateBool(guard, rec)) {
                continue;
            }
        }

        bool matched_ident = false;

        int match_cnt = SNetTencVariantsMatch(
            venc, 
            SNetTencTypeGetVariant(star_gnode->type, i), &matched_ident);

        if (match_cnt > 0 || (match_cnt == 0 && matched_ident)) {
            return true;
        }
    }

    return false;
}

/*----------------------------------------------------------------------------*/

static snet_gnode_t*
gnode_walk_hnd_star(snet_gnode_t *gnode, snet_handle_t *hnd)
{
    assert(gnode->type == GRAPH_NODE_TYPE_COMB_STAR);

    if (gnode->data.normal->entity.star->groot == NULL) {
        return NULL;
    }

    // First test the exit condition!
    // if true just return NULL so that the
    // walking continues to the next node. Otherwise
    // the walking is directed to the contained node!!
    snet_conslst_node_t *cnode = SNetHndGetConsNode(hnd);

    if (test_star_exit_cond(gnode, SNetConsLstNodeGetRecord(cnode))) {
        return NULL;
    }

    // Add dynamic index to the cons-node
    SNetConsLstNodeAddDynGInx(cnode, gnode->data.normal->inx);
   
    // Fix the dynamic index
    snet_ginx_t      *dyn_ginx      = SNetConsLstNodeGetDynGInx(cnode);
    snet_ginx_item_t  ginx_item_val = 1;

    if (!SNetConsLstNodeIsDynGInxNew(cnode)) {
        SNetGInxConcat(
            dyn_ginx, 
            gnode->data.normal->inx, 
            SNetGInxGetLen(dyn_ginx));
    }

    SNetGInxConcatArray(dyn_ginx, &ginx_item_val, 1); 

    return gnode->data.normal->entity.star->groot;
}

/*----------------------------------------------------------------------------*/

static snet_gnode_t*
gnode_walk_hnd_star_merge(snet_gnode_t *gnode, snet_handle_t *hnd)
{
    assert(gnode->type == GRAPH_NODE_TYPE_COMB_STAR);

    // First part is similar to the normal walk handler above. Test the
    // exit condition and decide whether to go into the contained network
    // again or not. One difference is that this routine assumes that
    // there is always a valid network (see assert() below) because it is
    // called after the contained has been processed at least once (so it
    // has to be valid otherwise this function would have never been called).
    snet_conslst_node_t *cnode = SNetHndGetConsNode(hnd);

    assert(gnode->data.normal->entity.star->groot != NULL);

    if (test_star_exit_cond(gnode, SNetConsLstNodeGetRecord(cnode))) {
        SNetConsLstNodeRemoveDynGInx(cnode);
        return NULL;
    }
    
    // It is going in the 'star' again. Because this is a "merge"
    // the only thing we have to do is to chop the index and increase
    // the value of the last item.
    unsigned int dyn_inx_new_len = 
        SNetGInxGetLen(gnode->data.normal->inx) + 1;

    snet_ginx_t *dyn_inx = SNetConsLstNodeGetDynGInx(cnode);

    // When returning back to a 'star' node
    // the node MUST ALWAYS have a dynamic index
    // and its length MUST be greater than the graph node's (+1)!!!
    assert(dyn_inx != NULL);
    assert(SNetGInxGetLen(dyn_inx) > dyn_inx_new_len);

    // Fix the dynamic index!
    SNetGInxChopRight(
        dyn_inx,
        SNetGInxGetLen(dyn_inx) - dyn_inx_new_len);

    SNetGInxIncrItemValue(dyn_inx, dyn_inx_new_len - 1, 1);

    return gnode->data.normal->entity.star->groot;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static snet_gnode_t*
gnode_walk_hnd_split(snet_gnode_t *gnode, snet_handle_t *hnd)
{
    assert(gnode->type == GRAPH_NODE_TYPE_COMB_SPLIT);

    if (gnode->data.normal->entity.split->groot == NULL) {
        return NULL;
    }

    snet_conslst_node_t *cnode = SNetHndGetConsNode(hnd);
    snet_record_t       *rec   = SNetConsLstNodeGetRecord(cnode);
    
    if (!SNetRecHasTag(rec, gnode->data.normal->entity.split->tag)) {
        const char *ginx_str =
            SNetGInxToString(gnode->data.normal->inx, NULL);

        SNetReportError(
            SNET_ERR_TYPE_ERROR,
            "index-split combinator "
            "(record does not have required tag)", ginx_str);

        SNetMemFree((void *) ginx_str);
        SNetOnError();
    }

    // Add dynamic index to the cons-node
    SNetConsLstNodeAddDynGInx(cnode, gnode->data.normal->inx);

    // !!PORTABILITY NOTE!!
    // The following code will not work as expected on systems
    // that use ILP64 and SILP64 data models if the data type
    // 'snet_ginx_item_t' is typedefed to 'long long' as it
    // currently is (see file graphindex.int.utc.h).     
    assert(sizeof(snet_ginx_item_t) == 2 * sizeof(unsigned int));

    unsigned int tag_val = 
        (unsigned int) SNetRecGetTag(
            rec, gnode->data.normal->entity.split->tag);

    // Here the additional index item that will be added will take the
    // value of the tag (with negative sign being a P label) instead of
    // the value of 1 as it happens in the 'star' combinator.
    snet_ginx_item_t ginx_item_val = -(((snet_ginx_item_t) tag_val) + 1);

    // !!END OF PORTABILITY NOTE!!

    // Fix the dynamic index.
    snet_ginx_t *dyn_ginx = SNetConsLstNodeGetDynGInx(cnode);    

    if (!SNetConsLstNodeIsDynGInxNew(cnode)) {
        SNetGInxConcat(
            dyn_ginx, 
            gnode->data.normal->inx, 
            SNetGInxGetLen(dyn_ginx));
    }

    SNetGInxConcatArray(dyn_ginx, &ginx_item_val, 1); 

    return gnode->data.normal->entity.split->groot;
}

static snet_gnode_t*
gnode_walk_hnd_split_merge(snet_gnode_t *gnode, snet_handle_t *hnd)
{
    // Unlike the 'star' above here we only need to
    // remove the dynamic index before exiting the
    // index split.
    SNetConsLstNodeRemoveDynGInx(SNetHndGetConsNode(hnd));

    // The network within the index split is executed
    // only once thus here we always return NULL to 
    // indicate to the "walking" routine to move forward.
    return NULL;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static bool gnode_hnd_extern_conn(snet_gnode_t *gnode, snet_handle_t *hnd)
{
    assert(gnode->type == GRAPH_NODE_TYPE_EXTERN_CONNECTION);

    const char *ginx_str = SNetGInxToString(gnode->data.normal->inx, NULL);

    SNetReportWarning(
        SNET_WRN_IGNORED_ENTITY,
        "external connextion", ginx_str, "not supported yet");

    SNetMemFree((void *) ginx_str);
    SNetOnWarning();

    return true;
}

/*----------------------------------------------------------------------------*/

static snet_gnode_t*
gnode_walk_hnd_extern_conn(snet_gnode_t *gnode, snet_handle_t *hnd)
{
    return NULL;
}

/*----------------------------------------------------------------------------*/

static snet_gnode_t*
gnode_walk_hnd_extern_conn_merge(snet_gnode_t *gnode, snet_handle_t *hnd)
{
    return NULL;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Infimum update and propagation related functions */
    
static thread void update_infimum(
    snet_gnode_t        *synccell_gnode,
    snet_conslst_node_t *cnode,
    shared snet_ginx_t  *infimum,
    shared snet_conslst_node_t *next_cnode)
{
    snet_ginx_t  *new_infimum   = NULL;
    snet_ginx_t  *cnode_dyn_inx = SNetConsLstNodeGetDynGInx(cnode);
    snet_gnode_t *gnode         = SNetConsLstNodeGetGraphNode(cnode);

    snet_ginx_t *cnode_inx = NULL;

    if (gnode != NULL && gnode->type != GRAPH_NODE_TYPE_NOP) {
        cnode_inx = (
            cnode_dyn_inx != NULL ?
            cnode_dyn_inx : gnode->data.normal->inx);
    }

    if (infimum == NULL) {
        // This indicates that the node given in "cnode" is
        // the starting one.
        //if (!SNetConsLstNodeIsHead(cnode) &&
        //    !(SNetConsLstNodeGetFlags(cnode) & CNODE_FLAG_INFIMUM_CHANGED)) {

        //    infimum    = NULL;
        //    next_cnode = NULL;
            
        //    return;
        //}

        conslst_node_reset_flag(cnode, CNODE_FLAG_INFIMUM_CHANGED);

        if (cnode_inx == NULL) {
            new_infimum = SNetGInxCreateCopy(
                SNetConsLstNodeGetMinGInx(cnode), true);

        } else {
            new_infimum = SNetGInxCalcInfimumEx(
                cnode_inx, SNetConsLstNodeGetMinGInx(cnode));
        }

    } else {
        SNetGInxSetValue(
            SNetConsLstNodeGetMinGInx(cnode), infimum, true);

        conslst_node_set_flag(cnode, CNODE_FLAG_INFIMUM_CHANGED);

        if (conslst_node_check_for_state(
                cnode,
                CONS_NODE_STATE_WALKING,
                CNODE_FLAG_ON_STATE_CHANGE_PROP_INFIMUM, 
                CNODE_SET_FLAGS_IF_COND_TRUE)) {

            SNetGInxDestroy(infimum);

            infimum    = NULL;
            next_cnode = NULL;

            return;
        } 

        new_infimum = (
            cnode_inx == NULL ? 
            infimum : SNetGInxCalcInfimumEx(cnode_inx, infimum));

        if (infimum != new_infimum) {
            SNetGInxDestroy(infimum);
        }
    }

    if (conslst_node_check_for_state(
            cnode,
            CONS_NODE_STATE_WAIT_SYNC, 0, CNODE_SET_FLAGS_NEVER)) {

        assert(gnode != NULL);
        assert(gnode->type == GRAPH_NODE_TYPE_SYNC);

        if (gnode != synccell_gnode) {
            family fid;
            place  gnode_mutex_plc = 
                SNetBaseTypeGetMutexPlace(SNetGNodeToBaseConst(gnode));

            create (
                fid; 
                gnode_mutex_plc; 0; 0; 1; 1;;)
                    try_synccell_output_th(gnode, cnode);

            sync(fid);
        }
    }

    infimum    = new_infimum;
    next_cnode = SNetConsLstNodeGetNext(cnode);
}

/*----------------------------------------------------------------------------*/

static void propagate_infimum(
    unsigned int create_local,
    snet_conslst_node_t *cnode, snet_gnode_t *synccell_gnode) 
{
    snet_ginx_t         *infimum    = NULL;
    snet_conslst_node_t *next_cnode = NULL;

    do {
        family fid;

        if (create_local > 0) {
            create (fid;; 0; 0; 1; 1;;)
                update_infimum(
                    synccell_gnode, cnode, infimum, next_cnode);

            create_local--;
            sync(fid);

        } else {
            place  cnode_mutex_plc =
                SNetBaseTypeGetMutexPlace(
                    SNetConsLstNodeToBaseConst(cnode));
            
            create (fid; cnode_mutex_plc; 0; 0; 1; 1;;)
                update_infimum(
                    synccell_gnode, cnode, infimum, next_cnode);

            sync(fid);
        }

        cnode = next_cnode;

    } while (cnode != NULL);

    if (infimum != NULL)
        SNetGInxDestroy(infimum);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static thread void
move_cons_node_to_gnode(snet_conslst_node_t *cnode, snet_gnode_t *gnode)
{
    // Moving means set the cons-nodes's graph node to
    // the found one and update its dynamic index (if
    // there is one).
    SNetConsLstNodeSetGraphNode(cnode, gnode);

    if (gnode == NULL) {
        // Remove its dynamic index if any!
        while (SNetConsLstNodeGetDynGInx(cnode) != NULL) {
            SNetConsLstNodeRemoveDynGInx(cnode);
        }

        return;
    }

    // If its not being moved at the end of the
    // graph the dynamic index needs "fixing"!!
    snet_ginx_t *dyn_inx = SNetConsLstNodeGetDynGInx(cnode);

    if (dyn_inx == NULL) {
        return;
    }

    unsigned int dyn_inx_len   = SNetGInxGetLen(dyn_inx);
    unsigned int gnode_inx_len = SNetGInxGetLen(gnode->data.normal->inx);

    if (gnode_inx_len == dyn_inx_len) {
        return;
    }

    if (gnode_inx_len < dyn_inx_len)
        SNetGInxChopRight(dyn_inx, dyn_inx_len - gnode_inx_len);
    else
        SNetGInxConcat(dyn_inx, gnode->data.normal->inx, dyn_inx_len);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/**
 * Graph Walking function; It returns true if the end of
 * of the network is reached.
 */

static bool graph_walk(snet_handle_t *hnd)
{
    snet_gnode_t *gnode              = NULL;
    snet_gnode_t *next_gnode         = NULL;
    snet_gnode_t *gnode_to_cache     = NULL;
    snet_gnode_contlink_t *gnode_lnk = NULL;

    if (SNetRecGetDescription(
        SNetHndGetConsNodeRecord(hnd)) != REC_DESCR_CTRL) {

        gnode = SNetConsLstNodeGetGraphNode(SNetHndGetConsNode(hnd));
    }

    while (gnode != NULL) {
        if (next_gnode != NULL) {
            gnode      = next_gnode;
            next_gnode = NULL;

        } else {
            gnode_lnk = (
                gnode->type == GRAPH_NODE_TYPE_NOP ?
                &gnode->data.nop->lnk : &gnode->data.normal->lnk);

            gnode = (
                gnode_lnk->cached_node == NULL ? 
                gnode_lnk->node : gnode_lnk->cached_node);

            assert(
                !gnode_lnk->merge || 
                 gnode->type == GRAPH_NODE_TYPE_COMB_STAR  || 
                 gnode->type == GRAPH_NODE_TYPE_COMB_SPLIT || 
                 gnode->type == GRAPH_NODE_TYPE_COMB_PARALLEL);
        }

        if (gnode == NULL) {
            continue;
        }

        if (gnode->type == GRAPH_NODE_TYPE_NOP) {
            continue;
        }

        snet_gnode_walk_hnd_fptr_t gnode_walk_hnd_func = (
            !gnode_lnk->merge ? 
            gnode->data.normal->walk_hnd_func : 
            gnode->data.normal->walk_hnd_func_merge);

        if (gnode_walk_hnd_func != NULL) {
            next_gnode = (*gnode_walk_hnd_func)(gnode, hnd);

            if (next_gnode != NULL) {
                if (next_gnode == gnode) {
                    next_gnode = NULL;
                }

                continue;
            }
        }

        if (gnode->data.normal->hnd_func != NULL) {
            // A graph node was found where the record
            // must "stop".
            //
            // Move the cons-list node to 
            // the "found" graph node and do the
            // propagation.
            snet_conslst_node_t *cnode = SNetHndGetConsNode(hnd);
          
            family fid;

            place  cnode_mutex_plc = 
                SNetBaseTypeGetMutexPlace(
                    SNetConsLstNodeToBaseConst(cnode));

            create (
                fid;
                cnode_mutex_plc; 0; 0; 1; 1;;)
                    move_cons_node_to_gnode(cnode, gnode);

            sync(fid);
            propagate_infimum(0, cnode, NULL);

            // Now we call the node's handler
            // and terminate the "walking".
            if (!(*gnode->data.normal->hnd_func)(gnode, hnd)) {
                // If the handler has made the cons-node a
                // "null node" then it must be moved to the
                // end of the graph. So we set "gnode" to
                // NULL before we break the loop so that
                // this movement will be done by the code
                // after the loop.
                //
                // The same goes if the record is ctrl record.
                if (SNetConsLstNodeIsNull(cnode) ||
                    SNetRecGetDescription(
                        SNetConsLstNodeGetRecord(cnode)) == REC_DESCR_CTRL) {

                    gnode = NULL;
                }

                break;
            }
        }
    }

    if (gnode == NULL) {
        // No node was found on which the record must stop. This
        // means the end of the network was reached!! In this
        // case we also need to "move" the cons-node to the
        // NULL node and propagate the infimum. 
        snet_conslst_node_t *cnode = SNetHndGetConsNode(hnd);
           
        family fid;

        place  cnode_mutex_plc = 
            SNetBaseTypeGetMutexPlace(
                SNetConsLstNodeToBaseConst(cnode));

        create (
            fid;
            cnode_mutex_plc; 0; 0; 1; 1;;)
                move_cons_node_to_gnode(cnode, gnode);

        sync(fid);
        propagate_infimum(0, cnode, NULL);

    } else if (gnode_to_cache != NULL) {
        /**
         * !!TODO!!: Cache gnode
         */
    }

    return (gnode == NULL);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Record output functions  */

static thread void 
output_buf_push(snet_buffer_t *buf, snet_record_t *rec)
{
    SNetBufPush(buf, rec);

#ifdef SVPSNETGWRT_USE_KILL_HACK_FOR_OUT_BUFFER_SUSPEND
    SNetDomainWakeupOutBufferWaitFamily(
        SNetBaseTypeGetDomain(SNetBufToBaseConst(buf)));
#endif
}

/*----------------------------------------------------------------------------*/

static void 
handle_rt_ctrl_record(snet_domain_t *snetd, snet_record_t *rec)
{
    /**
     * !!TODO!!: Perform ctrl operation desribed
     * by the ctrl record.
     */
    SNetRecDestroy(rec);
}

static void 
output_record(snet_domain_t *snetd, snet_record_t *rec)
{
    family fid;

    snet_buffer_t *out_buf = 
        SNetDomainGetOutBuffer(snetd);

    place buf_mutex_plc = 
        SNetBaseTypeGetMutexPlace(SNetBufToBase(out_buf));

    create (
        fid; 
        buf_mutex_plc; 0; 0; 1; 1;;)
            output_buf_push(out_buf, rec);

    sync(fid);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Functions to insert new nodes into the cons-list */

static thread void 
conslst_push_back_th(snet_conslst_t *lst, snet_conslst_node_t *n)
{
    snet_conslst_node_t *tail = SNetConsLstGetTail(lst);
    
    SNetConsLstPush(lst, n);

    conslst_node_set_flag(tail, CNODE_FLAG_INFIMUM_CHANGED);
    propagate_infimum(1, tail, NULL);
}

static thread void 
conslst_insert_before_th0(snet_conslst_node_t *n1, snet_conslst_node_t *n2)
{
    snet_conslst_node_t *n2_prev = SNetConsLstNodeGetPrevious(n2);

    SNetConsLstInsertBefore(n1, n2);

    conslst_node_set_flag(n2_prev, CNODE_FLAG_INFIMUM_CHANGED);
    propagate_infimum(3, n2_prev, NULL);
}

static thread void 
conslst_insert_before_th(snet_conslst_node_t *n1, snet_conslst_node_t *n2)
{
    snet_conslst_node_t *n2_prev = SNetConsLstNodeGetPrevious(n2);

    if (n2_prev == NULL) {
        SNetConsLstInsertBefore(n1, n2);

        conslst_node_set_flag(
            n1, 
            CNODE_FLAG_DISPOSABLE | CNODE_FLAG_INFIMUM_CHANGED);

        propagate_infimum(2, n1, NULL);
        return;
    }

    family fid;

    place  n2_prev_mutex_plc = 
        SNetBaseTypeGetMutexPlace(
            SNetConsLstNodeToBaseConst(n2_prev));

    create (
        fid;
        n2_prev_mutex_plc;
        0; 0; 1; 1;;) conslst_insert_before_th0(n1, n2);

    sync (fid);
}

static thread void 
conslst_push_back(snet_conslst_t *lst, snet_conslst_node_t *n)
{
    snet_conslst_node_t *tail = SNetConsLstGetTail(lst);

    if (tail == NULL) {
        // The list is empty. The infimum of the 
        // first node should be infinite. When
        // the node is created by default its infimum
        // is infinite. So we do not need to do anything
        // other than push it into the list.
        SNetConsLstPush(lst, n);

        // However the node must be marked as "disposable"
        // because there would be none to do it.
        conslst_node_set_flag(n, CNODE_FLAG_DISPOSABLE);
        return;
    }

    // The list is not empty 
    family fid;

    place  tail_mutex_plc = 
        SNetBaseTypeGetMutexPlace(
            SNetConsLstNodeToBaseConst(tail));

    create (
        fid;
        tail_mutex_plc;
        0; 0; 1; 1;;) conslst_push_back_th(lst, n);

    sync (fid);
}

static thread void
conslst_insert_before(snet_conslst_node_t *n1, snet_conslst_node_t *n2)
{
    family fid;

    place  n2_mutex_plc = 
        SNetBaseTypeGetMutexPlace(
            SNetConsLstNodeToBaseConst(n2));

    create (
        fid;
        n2_mutex_plc;
        0; 0; 1; 1;;) conslst_insert_before_th(n1, n2);

    sync (fid);
}

/*----------------------------------------------------------------------------*/

static snet_handle_t* 
conslst_insert_node(
    snet_domain_t *snetd, snet_handle_t *hnd, snet_record_t *rec)
{
    assert(snetd != NULL);
    assert(rec != NULL);

    assert(
        hnd == NULL || 
        SNetDomainIsSame(
            snetd, 
            SNetBaseTypeGetDomain(SNetHndToBase(hnd))));

    // Create a new cons-list node.
    snet_conslst_node_t *cnode = SNetConsLstNodeCreate(snetd);

    // Allocate mutex places for it (for the node itself and
    // for its infimum.
    snet_place_specs_t mutex_plc_specs = {
        false,
        true,
        PLACE_TYPE_SNET_RT_SPEC,
        NULL
    };

    SNetBaseTypeSetPlacesContracts(
        SNetConsLstNodeToBase(cnode),
        NULL,
        SNetPlaceAlloc(&mutex_plc_specs),
        NULL);

    // Set the graph node of the new cons-node. It will be
    // the root of the graph if 'hnd' is NULL (meaning the
    // cons-node is for a new input record) or to the graph-node
    // the cons-node of 'hnd' is (meaning the record is an output
    // record from a box with multiplicity greater than 1).
    if (hnd == NULL) {
        SNetConsLstNodeSetGraphNode(
            cnode,
            SNetDomainGetGraphRoot(snetd));

    } else {
        snet_conslst_node_t *pcnode = SNetHndGetConsNode(hnd);

        SNetConsLstNodeSetGraphNode(
            cnode, SNetConsLstNodeGetGraphNode(pcnode));

        // Also in this case we need to check whether the parent
        // cons-node has a dynamic index and if it does to add one
        // also to the new cons-node and it has to be the same
        // as the one of the parent. A special function is used
        // for this to deal also with the ref-count the cons-node
        // has for its dynamic index (see file conslist.utc for
        // more details).
        SNetConsLstNodeAddSameDynGInxAs(cnode, pcnode);
    }

    // Finally the node's state must be set
    // to WALKING.
    conslst_node_set_state(cnode, CONS_NODE_STATE_WALKING);

    // Now create a new handle!
    snet_handle_t *new_hnd = SNetHndCreate(cnode);

    // Setup mutex place for the handle
    SNetBaseTypeSetPlacesContracts(
        SNetHndToBase(new_hnd),
        NULL,
        SNetPlaceAlloc(&mutex_plc_specs),
        NULL);

    // The output record of the handle MUST 
    // be set to the given one.
    SNetHndSetOutRecord(new_hnd, rec);

    // Now we are ready to add the cons-node
    // to the cons-list.
    snet_conslst_t *conslst = SNetDomainGetConsList(snetd);

    place conslst_mutex_plc = 
        SNetBaseTypeGetMutexPlace(SNetConsLstToBase(conslst));

    if (hnd == NULL) {
        family fid;

        create (
            fid;
            conslst_mutex_plc; 0; 0; 1; 1;;)
                conslst_push_back(conslst, cnode);

        sync(fid);

    } else {
        snet_conslst_node_t *current_cnode = SNetHndGetConsNode(hnd);

        family fid;

        create (
            fid; conslst_mutex_plc; 0; 0; 1; 1;;)
                conslst_insert_before(cnode, current_cnode);

        sync(fid);
    }
    
    return new_hnd;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Output synchronization functions */

static thread void
process_conslst_node_for_output(
    bool is_start_node,
    shared snet_conslst_node_t *n,
    shared bool pop_node, shared bool prop_infimum)
{
    // Now if the node is at the head of the
    // cons-list then it is time to output its record
    // and dispose the node. Otherwise it will go to
    // to WAIT_OUT state and will be handled by 
    // a different GW instance which handles a
    // descendant node.
    if (!SNetConsLstNodeIsHead(n)) {
        prop_infimum = (
            !is_start_node ?
            false :
            conslst_node_set_state(n, CONS_NODE_STATE_WAIT_OUT));

        n = NULL;
        pop_node = false;

        return;
    }

    // The node is at the head of the cons-list thus we must
    // output its record. 
    snet_record_t *rec = SNetConsLstNodeGetRecord(n);

    // The record of a node can be NULL. This is when
    // a box outputs no records making the cons-node a "null" node.
    if (rec != NULL) {
        if (SNetRecGetDescription(rec) == REC_DESCR_CTRL
            && SNetRecGetCtrlMode(rec) == REC_CTRL_MODE_RT) {

            handle_rt_ctrl_record(
                SNetBaseTypeGetDomain(
                    SNetConsLstNodeToBase(n)), rec);

        } else {
            output_record(
                SNetBaseTypeGetDomain(
                    SNetConsLstNodeToBase(n)), rec);
        }

#if SVPSNETGWRT_DEBUG > 1
    } else {
        SNetReportWarningCustom("Removing NULL cons-node at output");
        SNetOnWarning();
#endif
    }

    pop_node     = true;
    prop_infimum = false;

    // Return to the creator the next node and 
    // that it must pop the current from the cons-list.
    n = SNetConsLstNodeGetNext(n);
}

/*----------------------------------------------------------------------------*/

static thread void conslst_pop_ex(snet_conslst_t *lst)
{
    SNetConsLstPop(lst);
}

static thread void conslst_pop(
    snet_conslst_t *lst, shared snet_conslst_node_t *n)
{
    //const char *ginx_str = 
    //    SNetGInxToString(
    //        SNetConsLstNodeGetOrdGInx(n), NULL);

    //printf("Popped CONS-NODE(%s)\n", ginx_str);
    //SNetMemFree((void *) ginx_str);

    family fid;

    place  n_mutex_plc = 
        SNetBaseTypeGetMutexPlace(
            SNetConsLstNodeToBaseConst(n));

    create (
        fid;
        n_mutex_plc;
        0; 0; 1; 1;;) conslst_pop_ex(lst);

    sync (fid);

    // The cons-node is not needed any more thus it can be destroyed.
    //
    // However we have to wait because if the GW instance for the 
    // ascendant node is still around it might be using the mutual
    // exclusive place of this node (at the final stage of the output
    // routine where it checks the state of the next node). So if 
    // we destroy the node (and the place with it) that instance might
    // crash or deadlock. For this reason we have to wait. We wait
    // until the DISPOSABLE flag for this node is set (which is set
    // by the GW of the ascendant node when it finishes with it and
    // not using the mutex place anymore).
    //
    // !!!TODO!!!: Another way must be found to do this because if the
    // GW instance fails to set the flag then there will be a deadolock.
    // For conventional systems if a GW instance fails any further crashes
    // of the system can be "expected" as part of an overall system failure.
    // In an adaptive system however such failures should be allowed and 
    // handled without the rest of the system failling because such a 
    // system is supposed to be able to adapt and recover from failures. 
    // Thus another solution is probably needed here!!!!
    while (!(SNetConsLstNodeGetFlags(n) & CNODE_FLAG_DISPOSABLE));

    // Now it is safe to destroy
    // the node.
    SNetConsLstNodeDestroy(n);
    
    // Return to the creator the new head of the list
    // as the "next" node.
    n = SNetConsLstGetHead(lst);
}

/*----------------------------------------------------------------------------*/

static void
output_waitting_records(
    unsigned int create_local,
    snet_gnode_t *synccell_gnode,
    snet_conslst_node_t *start_consnode)
{
    snet_conslst_t *conslst = SNetConsLstNodeGetList(start_consnode);

    place conslst_mutex_plc =
        SNetBaseTypeGetMutexPlace(SNetConsLstToBaseConst(conslst));

    // Starting with the given node all nodes in the cons-list
    // after it are checked. 
    snet_conslst_node_t *n = start_consnode;

    while (n != NULL) {
        snet_conslst_node_t *next_node = n;

        family fid;
        bool   pop_node      = false;
        bool   prop_infimum  = false;
        bool   is_start_node = (n == start_consnode);

        if (create_local > 0) {
            create_local--;

            create (fid;; 0; 0; 1; 1;;)
                process_conslst_node_for_output(
                    is_start_node, next_node, pop_node, prop_infimum);

        } else {
            place  consnode_mutex_plc =
                SNetBaseTypeGetMutexPlace(SNetConsLstNodeToBase(n));

            create (fid; consnode_mutex_plc; 0; 0; 1; 1;;)
                process_conslst_node_for_output(
                    is_start_node, next_node, pop_node, prop_infimum);
        }

        sync(fid);

        if (prop_infimum) {
            //printf("PROPAGATING INFIMUM!!!!\n");
            propagate_infimum(0, n, synccell_gnode);
        }

        // Remove the node from the list if
        // nessesary.
        if (pop_node) {
            next_node = n;

            // conslst_pop() will also destroy the node.
            create (
                fid;
                conslst_mutex_plc; 0; 0; 1; 1;;) 
                    conslst_pop(conslst, next_node);

            sync(fid);
        }

        if (next_node == NULL) {
            break;
        }

        // Before continuing to proecess the next node
        // its state must be checked. If its state is not WAIT_OUT
        // then we will stop (because any other state means that
        // either the node has not reached the end of the network
        // or if it has there is another GW instance that processes it
        // and will take care of it.
        bool continue_to_next = conslst_node_check_for_state_ts(
            next_node, CONS_NODE_STATE_WAIT_OUT, 0, CNODE_SET_FLAGS_NEVER);

        // Mark the "next" node as disposable (see comment in thread function
        // conslst_pop() for more details on this). This instance is the only
        // one that writes this flag while there is only one other that might
        // be reading it. Thus it should be safe to do it without using the
        // mutual exclussion place of the node. If we did then the problem
        // of the place being disposed before we are done with it will
        // remain (again see comment in conslst_pop() thread function for
        // more details). 
        conslst_node_set_flag(next_node, CNODE_FLAG_DISPOSABLE);

        if (!continue_to_next) {
            break;
        }

        n = next_node;
    }
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static void
prepare_handle_for_moving(
    snet_handle_t *hnd, bool new_handle, snet_record_t *fli_rec)
{
    assert(SNetHndGetOutRecord(hnd) != NULL);

    if (fli_rec != NULL) {
        // We need to handle flow inheritance. That means merge uncosumed
        // fields and tags from the input record to the output.
        // 
        // The SNetRecCopyItems() function does everything :)!!!.
        assert(SNetRecGetDescription(fli_rec) != REC_DESCR_CTRL);

        SNetRecCopyItems(
            fli_rec, 
            SNetHndGetOutRecord(hnd), 
            REC_ITEMS_COPY_UNCONSUMED | REC_ITEMS_COPY_MOVE, NULL);
    }

    snet_conslst_node_t *cnode = SNetHndGetConsNode(hnd);

    if (!new_handle) {
        // If it is not a new handle then the function is called
        // after a box emited its last record (or its only record
        // if its multiplicity is 1) in which case the input to
        // record must be destroyed.
        //
        // The handling of flow-inheritance above has made sure that
        // any remaining items in the record are the consumed ones.
        // These will be disposed by destroying the record (unless 
        // the dispose mode of the record has been set to the value
        // "REC_DATA_DISPOSE_MODE_NONE" by the user in which case it
        // means the user has other means to dispose those items and
        // wants to do it explicitly; thus we do not interfere; see
        // the copy and destroy functions for records in the file
        // "record.utc" for more details).
        SNetRecDestroy(SNetConsLstNodeGetRecord(cnode));
    }

    // The handle's out record must now become the
    // cons-node's current record and the handle to be
    // reset (to have a NULL out record).
    SNetConsLstNodeSetRecord(cnode, SNetHndGetOutRecord(hnd));
    SNetHndSetOutRecord(hnd, NULL);
}

/*----------------------------------------------------------------------------*/

static thread void advance_handle(snet_handle_t *hnd)
{
    assert(hnd != NULL);

    if (graph_walk(hnd)) {
        // The end of the network has been reached!! We must 
        // do some output synchronization and housekeeping work.

        // Now we must output the current cons-node's record and 
        // any records from cons-nodes that were waitting for our
        // cons-node to complete (this process will also destroy 
        // cons-nodes not needed anymore).
        output_waitting_records(0, NULL, SNetHndGetConsNode(hnd));

        // The handle is not needed any more
        // thus it can be destroyed!
        SNetHndDestroy(hnd);
    }
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Module's "public" functions */

void SNetGWSetupNormalGNodeHndFuncs(snet_gnode_t *n)
{
    assert(n != NULL);
    assert(n->type != GRAPH_NODE_TYPE_NOP);

    snet_normal_gnode_t *normal = n->data.normal;

    switch (n->type) {
        case GRAPH_NODE_TYPE_BOX:
            normal->hnd_func            = &gnode_hnd_box;
            normal->walk_hnd_func       = NULL;
            normal->walk_hnd_func_merge = NULL;
            break;

        case GRAPH_NODE_TYPE_SYNC:
            normal->hnd_func            = &gnode_hnd_synccell;
            normal->walk_hnd_func       = NULL;
            normal->walk_hnd_func_merge = NULL;
            break;

        case GRAPH_NODE_TYPE_FILTER:
            normal->hnd_func            = &gnode_hnd_filter;
            normal->walk_hnd_func       = &gnode_walk_hnd_filter;
            normal->walk_hnd_func_merge = NULL;
            break;

        case GRAPH_NODE_TYPE_COMB_STAR:
            normal->hnd_func            = NULL;
            normal->walk_hnd_func       = &gnode_walk_hnd_star;
            normal->walk_hnd_func_merge = &gnode_walk_hnd_star_merge;
            break;

        case GRAPH_NODE_TYPE_COMB_SPLIT:
            normal->hnd_func            = NULL;
            normal->walk_hnd_func       = &gnode_walk_hnd_split;
            normal->walk_hnd_func_merge = &gnode_walk_hnd_split_merge;
            break;

        case GRAPH_NODE_TYPE_COMB_PARALLEL:
            normal->hnd_func            = NULL;
            normal->walk_hnd_func       = &gnode_walk_hnd_parallel;
            normal->walk_hnd_func_merge = NULL;
            break;

        case GRAPH_NODE_TYPE_EXTERN_CONNECTION:
            normal->hnd_func            = &gnode_hnd_extern_conn;
            normal->walk_hnd_func       = &gnode_walk_hnd_extern_conn;
            normal->walk_hnd_func_merge = &gnode_walk_hnd_extern_conn_merge;
            break;

        default:
            // This should never happen!! It is here
            // only so that the compiler does not 
            // complain for unhandled cases!!!
            return;
    }
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* SNetGWxxx() thread functions */

thread void SNetGW(snet_handle_t *hnd, snet_record_t *rec)
{
    // 1. hnd != NULL && rec == NULL
    //    Continue processing of the cons-node pointed by "hnd". Output
    //    record within the handle.
    //
    // 2. hnd != NULL && rec != NULL
    //    New record due to box having multiplicity greater than 1. New
    //    cons-node required to be inserted after the node pointed by
    //    "hnd".
    assert(hnd != NULL);
    assert(SNetHndGetConsNodeRecord(hnd) != NULL);

    family fid;

    snet_domain_t *snetd = 
        SNetBaseTypeGetDomain(SNetHndToBase(hnd));

    snet_handle_t *hnd_local = (
        rec == NULL ?
        hnd : conslst_insert_node(snetd, hnd, rec));

    if (SNetHndGetOutRecordsCount(hnd) == 2) {
        prepare_handle_for_moving(
            hnd_local,
            (hnd != hnd_local),
            SNetHndGetConsNodeRecord(hnd));

    } else { 
        prepare_handle_for_moving(
            hnd_local, (hnd != hnd_local), NULL);
    }

    create<nosync> (fid;; 0; 0; 1; 1;;) advance_handle(hnd_local);
}

thread void SNetGWInitial(snet_domain_t *snetd, snet_record_t *rec)
{
    assert(snetd != NULL);
    assert(rec != NULL);

    family fid;

    snet_handle_t *hnd = 
        conslst_insert_node(snetd, NULL, rec);

    prepare_handle_for_moving(hnd, true, NULL);

    create<nosync> (fid;; 0; 0; 1; 1;;) advance_handle(hnd);
}

/*------------------------------- END OF FILE --------------------------------*/
/*----------------------------------------------------------------------------*/

