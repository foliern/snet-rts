/*----------------------------------------------------------------------------*/
/*
      -------------------------------------------------------------------

           * * * * ! SVP S-Net Graph Walker Runtime (demo) ! * * * *

                   Computer Systems Architecture (CSA) Group
                             Informatics Institute
                         University Of Amsterdam  2008
                         
      -------------------------------------------------------------------

    File Name      : graphindex.utc

    File Type      : Code File

    ---------------------------------------

    File 
    Description    :

    Updates 
    Description    : N/A

*/
/*----------------------------------------------------------------------------*/

#include "graphindex.int.utc.h"

#include "memmng.int.utc.h"
#include "plcmng.int.utc.h"

/*---*/

#include <string.h>
#include <stdlib.h>

/*----------------------------------------------------------------------------*/
/**
 * Datatypes for an index
 */
typedef struct {
    unsigned int ref_cnt;
    unsigned int len;
    unsigned int buf_sz;

    /*---*/

    snet_ginx_item_t *items;

} snet_ginx_data_t;

/*---*/

struct graph_index {
    snet_ginx_data_t *data;

}; // graph_index;

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Module's static functions */

static snet_ginx_data_t* alloc_data_struct(int init_len)
{
    void *buf = SNetMemAlloc(
        sizeof(snet_ginx_data_t) +
        sizeof(snet_ginx_item_t) * init_len +
        sizeof(snet_ginx_item_t) * SVPSNETGWRT_GRAPH_INDEX_INCR_STEP);

    snet_ginx_data_t *ginxd = (snet_ginx_data_t *) buf;

    ginxd->ref_cnt = 1;
    ginxd->len     = 0;
    ginxd->buf_sz  = init_len + SVPSNETGWRT_GRAPH_INDEX_INCR_STEP;
    ginxd->items   = (snet_ginx_item_t *) (ginxd + 1);

    return ginxd;
}

/*----------------------------------------------------------------------------*/

static snet_ginx_data_t* realloc_data_struct(
    snet_ginx_t *inx, 
    unsigned int new_len,
    unsigned int copy_start, unsigned int copy_count)
{
    bool alloc_new = (inx->data == NULL ? true : inx->data->ref_cnt > 1);

    if (alloc_new) {
        snet_ginx_data_t *old_data = inx->data;

        inx->data = alloc_data_struct(new_len);

        if (old_data != NULL) {
            old_data->ref_cnt--;

            if(copy_count > 0) {
                SNetMemCopy(
                    old_data->items + copy_start,
                    inx->data->items, copy_count * sizeof(snet_ginx_item_t));
            }
        }

        inx->data->len = copy_count;

        return old_data;
    }

    if (copy_count > 0 && copy_start > 0) {
        SNetMemCopy(
            inx->data->items + copy_start,
            inx->data->items, copy_count * sizeof(snet_ginx_item_t));
    }

    inx->data->len = copy_count;

    if (inx->data->buf_sz < new_len || 
        inx->data->buf_sz > new_len + (
            2 * SVPSNETGWRT_GRAPH_INDEX_INCR_STEP)) {

        void *buf = SNetMemRealloc(
            inx->data,
            sizeof(snet_ginx_data_t) +
            sizeof(snet_ginx_item_t) * new_len +
            sizeof(snet_ginx_item_t) * SVPSNETGWRT_GRAPH_INDEX_INCR_STEP);

        inx->data         = (snet_ginx_data_t *)(buf);
        inx->data->items  = (snet_ginx_item_t *)(inx->data + 1);
        inx->data->buf_sz = new_len + SVPSNETGWRT_GRAPH_INDEX_INCR_STEP;
    }

    return NULL;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static unsigned int str_ginx_len(const char *str)
{
    if (str == NULL) {
        return 0;
    }

    const char *c = str;
    unsigned int len = 0;

    while (*c != 0) {
        if (*c == '.') {
            len++;
        }

        ++c;
    }

    return (c == str ? 0 : len + 1);
}

/*----------------------------------------------------------------------------*/

static void set_from_str(
    snet_ginx_item_t *inx_item, const char *str, unsigned int str_len)
{
    char *inx_item_buf = (char *) SNetMemAlloc(sizeof(char) * (str_len + 1));

    while (*str != 0) {
        char *inx_buf_item = inx_item_buf;

        while (*str != '.' && *str != 0) {
            *inx_buf_item = *str;

            ++str;
            ++inx_buf_item;
        }

        *inx_buf_item = 0;
        *inx_item     = (snet_ginx_item_t) strtol(inx_item_buf, NULL, 10);

        if (*str != 0) {
            ++str;
        }

        ++inx_item;
    }

    SNetMemFree(inx_item_buf);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static snet_ginx_cmp_result_t
compare(const snet_ginx_t *inx1, const snet_ginx_t *inx2, bool ext)
{
    assert(inx1 != NULL);
    assert(inx2 != NULL);

    if (inx1 == inx2)
        return GRAPH_INX_CMP_RES_EQUAL;

    if (inx1->data == inx2->data)
        return GRAPH_INX_CMP_RES_EQUAL;

    // Check if either one is infinite
    if (inx2->data == NULL)
        return GRAPH_INX_CMP_RES_LESS;

    if (inx1->data == NULL)
        return GRAPH_INX_CMP_RES_GREATER;

    // Check index items one by one
    unsigned int min_len = (
        inx1->data->len < inx2->data->len ? 
        inx1->data->len : inx2->data->len);

    for (unsigned int i=0; i < min_len; i++) {
        snet_ginx_item_t inx1_it = SNetGInxGetItemValue(inx1, i);
        snet_ginx_item_t inx2_it = SNetGInxGetItemValue(inx2, i);

        if (inx1_it > 0 && inx2_it > 0) {
            if (inx1_it < inx2_it)
                return GRAPH_INX_CMP_RES_LESS;
            else if (inx1_it > inx2_it)
                return GRAPH_INX_CMP_RES_GREATER;
        }

        if (ext && (inx1_it == 0 || inx2_it == 0)) {
            continue;
        }

        if (inx1_it != inx2_it)
            return GRAPH_INX_CMP_RES_UNDEFINED;
    }

    if (inx1->data->len == inx2->data->len) {
        return GRAPH_INX_CMP_RES_EQUAL;
    }

    // Check again for infinite (that an index is 
    // infinite is indicated with either data == NULL
    // checked above or data->len == 0 which we check now.
    if (inx2->data->len == 0)
        return GRAPH_INX_CMP_RES_LESS;

    if (inx1->data->len == 0)
        return GRAPH_INX_CMP_RES_GREATER;
   
    // Finnaly compare the lengths
    return (inx1->data->len < inx2->data->len ?
        GRAPH_INX_CMP_RES_LESS : GRAPH_INX_CMP_RES_GREATER);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

static snet_ginx_t*
calc_infimum(const snet_ginx_t *inx1, const snet_ginx_t *inx2, bool ext)
{
    assert(inx1 != NULL);
    assert(inx2 != NULL);

    if (SNetGInxIsInfinite(inx1))
        return SNetGInxCreateCopy(inx2, true);

    if (SNetGInxIsInfinite(inx2))
        return SNetGInxCreateCopy(inx1, true);

    snet_ginx_t *infimum = SNetGInxCreate();

    unsigned int min_len = (
        inx1->data->len < inx2->data->len ? 
        inx1->data->len : inx2->data->len);

    for (unsigned int i=0; i < min_len; i++) {
        snet_ginx_item_t inx1_it = SNetGInxGetItemValue(inx1, i);
        snet_ginx_item_t inx2_it = SNetGInxGetItemValue(inx2, i);

        if (inx1_it > 0 && inx2_it > 0) {
            snet_ginx_item_t *min = (
                inx1_it < inx2_it ? &inx1_it : &inx2_it);

            SNetGInxConcatArray(infimum, min, 1);

        } else {
            if (inx1_it == inx2_it) {
                SNetGInxConcatArray(infimum, &inx1_it, 1);
                continue;
            }

            if (!ext || inx1_it > 0 || inx2_it > 0) {
                break;
            }
            
            if (infimum->data->len > 0)
                SNetGInxConcatStr(infimum, "0");
            else
                SNetGInxConcatStr(infimum, "1.0");
        }
    }

    if (infimum->data->len == 0)
        SNetGInxConcatStr(infimum, "1");

    return infimum;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Initialization, Creation and Destruction */

void SNetGInxInit(snet_ginx_t *inx)
{
    assert(inx != NULL);
    inx->data = NULL;
}

void SNetGInxInitCopy(snet_ginx_t *inx, const snet_ginx_t *val, bool clone)
{
    assert(inx != val);

    assert(inx != NULL);
    assert(val != NULL);

    if (inx == val) {
        return;
    }

    if (val->data == NULL) {
        inx->data = NULL;
        return;
    }

    if (! clone) {
        inx->data = val->data;
        inx->data->ref_cnt++;

        return;
    }

    inx->data = alloc_data_struct(val->data->len); 

    SNetMemCopy(
        val->data->items,
        inx->data->items,
        val->data->len * sizeof(snet_ginx_item_t));

    inx->data->len = val->data->len;
}

void SNetGInxInitFromStr(snet_ginx_t *inx, const char *val)
{
    assert(inx != NULL);

    if (val == NULL) {
        inx->data = NULL;
        return;
    }

    unsigned int val_len = (unsigned int) str_ginx_len(val);

    inx->data      = alloc_data_struct(val_len);
    inx->data->len = val_len;

    set_from_str(inx->data->items, val, strlen(val));
}

void SNetGInxInitFromArray(
    snet_ginx_t *inx, const snet_ginx_item_t *arr, unsigned int arr_sz)
{
    assert(inx != NULL);
    assert(arr != NULL);

    inx->data = alloc_data_struct(arr_sz); 

    SNetMemCopy(
        arr,
        inx->data->items,
        arr_sz * sizeof(snet_ginx_item_t));

    inx->data->len = arr_sz;
}

/*----------------------------------------------------------------------------*/

snet_ginx_t* SNetGInxCreate()
{
    snet_ginx_t *inx = (snet_ginx_t *) SNetMemAlloc(sizeof(snet_ginx_t));

    SNetGInxInit(inx);
    return inx;
}

snet_ginx_t* SNetGInxCreateCopy(const snet_ginx_t *val, bool clone)
{
    assert(val != NULL);

    snet_ginx_t *inx = (snet_ginx_t *) SNetMemAlloc(sizeof(snet_ginx_t));

    SNetGInxInitCopy(inx, val, clone);
    return inx;
}

snet_ginx_t* SNetGInxCreateFromStr(const char *val)
{
    snet_ginx_t *inx = (snet_ginx_t *) SNetMemAlloc(sizeof(snet_ginx_t));

    SNetGInxInitFromStr(inx, val);
    return inx;
}

snet_ginx_t* 
SNetGInxCreateFromArray(const snet_ginx_item_t *arr, unsigned int arr_sz)
{
    assert(arr != NULL);

    snet_ginx_t *inx = (snet_ginx_t *) SNetMemAlloc(sizeof(snet_ginx_t));

    SNetGInxInitFromArray(inx, arr, arr_sz);
    return inx;
}

/*----------------------------------------------------------------------------*/

void SNetGInxDestroy(snet_ginx_t *inx)
{
    assert(inx != NULL);

    if (inx->data != NULL) {
        if (--inx->data->ref_cnt == 0) {
            SNetMemFree(inx->data);
        }
    }

    SNetMemFree(inx);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Value changing */

void SNetGInxSetToInfinite(snet_ginx_t *inx)
{
    assert(inx != NULL);

    if (inx->data == NULL) {
        return;
    }

    if (inx->data->ref_cnt > 1) {
        inx->data->ref_cnt--;
        inx->data = NULL;

        return;
    }
   
    realloc_data_struct(inx, 0, 0, 0);

    inx->data->len = 0;
}

/*----------------------------------------------------------------------------*/

void SNetGInxSetValue(
    snet_ginx_t *inx1,
    const snet_ginx_t *inx2, bool clone)
{
    assert(inx1 != NULL);
    assert(inx2 != NULL);

    if (inx1 == inx2) {
        return;
    }

    if (inx1->data == inx2->data) {
        return;
    }

    if (! clone) {
        if (inx1->data != NULL) {
            if (--inx1->data->ref_cnt == 0) {
                SNetMemFree(inx1->data);
            }
        }

        inx1->data = inx2->data;

        if (inx1->data != NULL)
            inx1->data->ref_cnt++;

        return;
    }

    if (inx2->data == NULL) {
        if (inx1->data != NULL)
            realloc_data_struct(inx1, 0, 0, 0);

    } else {
        realloc_data_struct(inx1, inx2->data->len, 0, 0);

        SNetMemCopy(
            inx2->data->items,
            inx1->data->items,
            inx2->data->len * sizeof(snet_ginx_item_t));

        inx1->data->len = inx2->data->len;
    } 
}

void SNetGInxSetValueFromStr(snet_ginx_t *inx, const char *val)
{
    assert(inx != NULL);

    if (val == NULL) {
        if (inx->data != NULL)
            realloc_data_struct(inx, 0, 0, 0);

        return;
    }

    unsigned int val_len = str_ginx_len(val);

    realloc_data_struct(inx, val_len, 0, 0);
    set_from_str(inx->data->items, val, strlen(val));

    inx->data->len = val_len;
}

void SNetGInxSetValueFromArray(
    snet_ginx_t *inx,
    const snet_ginx_item_t *arr, unsigned int arr_sz)
{
    assert(inx != NULL);
    assert(arr != NULL);

    realloc_data_struct(inx, arr_sz, 0, 0);

    SNetMemCopy(
        arr,
        inx->data->items,
        arr_sz * sizeof(snet_ginx_item_t));

    inx->data->len = arr_sz;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Item manipulation */

snet_ginx_item_t 
SNetGInxGetItemValue(const snet_ginx_t *inx, unsigned int pos)
{
    assert(inx != NULL);
    assert(inx->data != NULL);
    assert(inx->data->len > pos);

    return inx->data->items[pos];
}

/*----------------------------------------------------------------------------*/

void SNetGInxSetItemValue(
    snet_ginx_t *inx,
    unsigned int pos, snet_ginx_item_t val)
{
    assert(inx != NULL);
    assert(inx->data != NULL);
    assert(inx->data->len > pos);

    realloc_data_struct(inx, inx->data->len, 0, inx->data->len);

    inx->data->items[pos] = val;
}

void SNetGInxIncrItemValue(
    snet_ginx_t *inx,
    unsigned int pos, snet_ginx_item_t val)
{
    assert(inx != NULL);
    assert(inx->data != NULL);
    assert(inx->data->len > pos);

    realloc_data_struct(inx, inx->data->len, 0, inx->data->len);

    inx->data->items[pos] += val;
}

void SNetGInxDecrItemValue(
    snet_ginx_t *inx,
    unsigned int pos, snet_ginx_item_t val)
{
    assert(inx != NULL);
    assert(inx->data != NULL);
    assert(inx->data->len > pos);

    realloc_data_struct(inx, inx->data->len, 0, inx->data->len);

    inx->data->items[pos] -= val;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Properties retrieval */

bool SNetGInxIsInfinite(const snet_ginx_t *inx)
{
    assert(inx != NULL);

    if (inx->data == NULL) {
        return true;
    }

    if (inx->data->len == 0) {
        return true;
    }

    return false;
}

/*----------------------------------------------------------------------------*/

unsigned int SNetGInxGetLen(const snet_ginx_t *inx)
{
    assert(inx != NULL);
    
    if (inx->data == NULL) {
        return 0;
    }

    return inx->data->len;
}

unsigned int SNetGInxGetBufSize(const snet_ginx_t *inx)
{
    assert(inx != NULL);

    if (inx->data == NULL) {
        return 0;
    }

    return inx->data->buf_sz;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Comparison */

snet_ginx_cmp_result_t
SNetGInxCompare(const snet_ginx_t *inx1, const snet_ginx_t *inx2)
{
    return compare(inx1, inx2, false);
}

snet_ginx_cmp_result_t
SNetGInxCompareEx(const snet_ginx_t *inx1, const snet_ginx_t *inx2)
{
    return compare(inx1, inx2, true);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Infimum calculation */

snet_ginx_t*
SNetGInxCalcInfimum(const snet_ginx_t *inx1, const snet_ginx_t *inx2)
{
    return calc_infimum(inx1, inx2, false);
}

snet_ginx_t*
SNetGInxCalcInfimumEx(const snet_ginx_t *inx1, const snet_ginx_t *inx2)
{
    return calc_infimum(inx1, inx2, true);
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Concatenation */

void SNetGInxConcat(
    snet_ginx_t *inx1, 
    const snet_ginx_t *inx2, unsigned int start_item_inx)
{
    assert(inx1 != NULL);
    assert(inx2 != NULL);
    assert(start_item_inx < SNetGInxGetLen(inx2));

    unsigned int len1 = SNetGInxGetLen(inx1);
    unsigned int len2 = SNetGInxGetLen(inx2);

    if (len2 == 0) {
        return;
    }

    len2 -= start_item_inx;

    realloc_data_struct(inx1, len1 + len2, 0, len1);

    SNetMemCopy(
        inx2->data->items + len2,
        inx1->data->items + len1,
        len2 * sizeof(snet_ginx_item_t));

    inx1->data->len = len1 + len2;
}

void SNetGInxConcatStr(snet_ginx_t *inx, const char *str)
{
    assert(inx != NULL);

    if (str == NULL) {
        return;
    }

    unsigned int len1 = SNetGInxGetLen(inx);
    unsigned int len2 = str_ginx_len(str);

    realloc_data_struct(inx, len1 + len2, 0, len1);
    set_from_str(inx->data->items + len1, str, strlen(str));

    inx->data->len = len1 + len2;
}

void SNetGInxConcatArray(
    snet_ginx_t *inx,
    const snet_ginx_item_t *arr, unsigned int arr_sz)
{
    assert(inx != NULL);
    assert(arr != NULL);

    unsigned int len = SNetGInxGetLen(inx);

    if (arr_sz == 0) {
        return;
    }

    realloc_data_struct(inx, len + arr_sz, 0, len);

    SNetMemCopy(
        arr,
        inx->data->items + len,
        arr_sz * sizeof(snet_ginx_item_t));

    inx->data->len = len + arr_sz;
}

/*----------------------------------------------------------------------------*/
/* Editting */

void SNetGInxChopLeft(snet_ginx_t *inx, unsigned int count)
{
    assert(inx != NULL);
    assert(inx->data != NULL);
    assert(inx->data->len >= count);

    if (count == 0) {
        return;
    }

    unsigned int new_len = inx->data->len - count;

    realloc_data_struct(inx, new_len, count, new_len);

    inx->data->len = new_len;
}

void SNetGInxChopRight(snet_ginx_t *inx, unsigned int count)
{
    assert(inx != NULL);
    assert(inx->data != NULL);
    assert(inx->data->len >= count);

    if (count == 0) {
        return;
    }

    unsigned int new_len = inx->data->len - count;

    realloc_data_struct(inx, new_len, 0, new_len);
    
    inx->data->len = new_len;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Convertion */

snet_ginx_item_t* 
SNetGInxToArray(const snet_ginx_t *inx, snet_ginx_item_t *arr)
{
    assert(inx != NULL);
    assert(arr != NULL);

    if (inx->data == NULL) {
        return NULL;
    }

    if (inx->data->len == 0) {
        return NULL;
    }

    SNetMemCopy(
        inx->data->items,
        arr,
        inx->data->len * sizeof(snet_ginx_item_t));

    return arr;
}

/*----------------------------------------------------------------------------*/

const char* 
SNetGInxToString(const snet_ginx_t *inx, char *str)
{
    assert(inx != NULL);

    if (inx->data == NULL) {
        return NULL;
    }

    if (inx->data->len == 0) {
        return NULL;
    }

    char *c = str;
    char *new_str = NULL;
    unsigned int new_str_sz = 0;

    if (str == NULL) {
        new_str_sz = SVPSNETGWRT_GRAPH_INDEX_ITEM_MAX_DEC_DIGITS;
        new_str    = (char *) SNetMemAlloc(new_str_sz * sizeof(char));

        c = new_str;
    }

    unsigned int str_len = 0;
    unsigned int item_len = 0;

    for (unsigned int i=0; i < inx->data->len; i++) {
        if (i == inx->data->len - 1) {
            item_len = snprintf(
                c,
                SVPSNETGWRT_GRAPH_INDEX_ITEM_MAX_DEC_DIGITS, 
                "%lld", 
                (long long) inx->data->items[i]);

        } else {
            item_len = snprintf(
                c, 
                SVPSNETGWRT_GRAPH_INDEX_ITEM_MAX_DEC_DIGITS,
                "%lld.", 
                (long long) inx->data->items[i]);
        }

        if (item_len < 0) {
            SNetReportError(
                SNET_ERR_UNEXPECTED,
                "failed to convert graph index to string");

            SNetOnError();
        }
            
        if (item_len >= SVPSNETGWRT_GRAPH_INDEX_ITEM_MAX_DEC_DIGITS) {
            SNetReportError(
                SNET_ERR_UNEXPECTED,
                "failed to convert graph index to string "
                "due to index item exceeding max size in decimal digits");

            SNetOnError();
        }

        str_len += item_len;

        if (str == NULL) {
            if (new_str_sz - str_len <
                SVPSNETGWRT_GRAPH_INDEX_ITEM_MAX_DEC_DIGITS) {

                new_str_sz += SVPSNETGWRT_GRAPH_INDEX_ITEM_MAX_DEC_DIGITS;

                new_str = (char *) 
                    SNetMemRealloc(new_str, new_str_sz * sizeof(char));

                c = new_str + str_len;
                continue;
            }
        }

        c += item_len;
    }

    (*c) = 0;

    if (str == NULL) {
        new_str = (char *)
            SNetMemRealloc(new_str, str_len + 1 * sizeof(char));
    }

    return (str != NULL ? str : new_str);
}

/*------------------------------- END OF FILE --------------------------------*/
/*----------------------------------------------------------------------------*/

