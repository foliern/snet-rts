/* Multiply matrices A and B. There are <nodes> nodes in the system.*/


net matrix({A, B, <A_width>, <A_height>, <B_width>, <B_height>, <nodes>}
            -> {C, <C_width>, <C_height>})
{


  /* Produce rows from <first> to <last> of C by multiplying rows of A with B */

  box multiply((a, B, <A_width>, <A_height>, <B_width>, <B_height>, <first>, <last>)
                 -> (c, <C_width>, <C_height>, <first>, <last>));

  /* 
   * Split A between the nodes Each node get equaly many rows of A 
   * B is copied so tha teach node gets its own instance 
   * These tasks are done in parallel and the results are combined so that
   * each record contains A and B. 
   * 
   */ 

  net pre
  {

    /* Split A */

    box split((A, <A_width>, <A_height>, <nodes>)
               -> (a, <A_width>, <A_height>, <node>, <first>, <last>));


    /* Copy B, <T> is 1 if there is only one node, this information is later 
     * used to bypass the merging process. 
     *
     */

    net copy({B, <n>, <B_width>, <B_height>, <nodes>}
              -> {B, <B_width>, <B_height>, <T>})
    {

    } connect [{B, <n>, <B_width>, <B_height>, <nodes>} ->
                if <nodes == 1> then
                  {B,<T=1> ,<B_width>, <B_height>} 
                else if <n > 1> then
                  {B, <n=n - 1>, <B_width>, <B_height>, <nodes>}; 
                  {B, <T=0>, <B_width>, <B_height>}
                else
                  {B, <T=0>, <B_width>, <B_height>}
              ]*{<T>};
   

  } connect [{A, B, <A_width>, <A_height>, <B_width>, <B_height>, <nodes>} ->
              {A, <A_width>, <A_height>, <nodes>};
              {B, <n=A_height>, <B_width>, <B_height>, <nodes>}]
            .. (split|copy)
            .. [|{a, <first>, <last>, <A_width>, <A_height>, <node>},{B, <B_width>, <B_height>, <T>}|]*{a, B}
            .. [{<T>} -> if <T == 0> then {} else {<T>}]; 


  /* Merge the calculated rows of C into one matrix.
   *
   */

  net merge 
  {

    /* Reserves memory for the matrix. */

    box init((array, <C_width>, <C_height>, <last>)
               -> (C, <C_width>, <C_height>, <last>));


    /* Merges rows c (rows from <first> to <last>) into the matrix  */

    box merger((C, c, <C_width>, <C_height>, <first>, <last>)
               -> (C, <C_width>, <C_height>, <first>, <last>));


  } connect
     /* Only one chunk, rename it and bypass the merging process */

     [{c, <first>, <last>, <C_width>, <C_height>, <T>, <node>} -> 
        {C=c, <C_width>, <C_height>}
     ] 
    |    
      /* Merge all the chuncks. Chunk with row 0 is used as the base matrix. */
     (
      [{c, <node>, <C_width>, <C_height>} ->
         if <node == 0> then 
           {array=c, <C_width>, <C_height>}
         else
           {c, <C_width>, <C_height>}
      ] 
      .. (
          (init .. [{<first>, <last>} -> {<count= last - first + 1>}]) 
          |
           [{}->{}]
         ) 

      .. ( [|{C, <C_width>, <C_height>, <count>},{c, <first>, <last>}|] 
           .. (
               (merger ..[{<count>, <C_height>, <first>, <last>} ->
                           if <count + (last - first + 1) == C_height> then
                             {<C_height>, <R>}
                           else
                             {<count= count + (last - first + 1)>, <C_height>}
                         ]
               )
                | 
               [{}->{}]
              )
         )*{<R>} .. [{<R>} -> {}]
      );

} connect pre .. multiply!@<node> .. merge;
