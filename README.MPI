                             Distributed S-Net

Distributed S-Net is a version of S-Net that can be executed 
with multiprocessors that work in distributed memory, like with
computing clusters. This document describes how to compile and 
use the distributed S-Net.

The distributed implementation is based on the Message-Passing 
Interface, MPI.


Distributed S-Net and network interface
=======================================

The network interface also works with the distributed S-Net, but
there are some differences on its behavior because of the MPI 
implementations.

Input and output with files (-i and -o parameters) work correctly
as long as the files can be accessed by the MPI process that has the
global input or output of the S-Net program.

Input and output with standard input and output streams may or may not
work correctly depending on the MPI implementation. The MPI standard 
does not specify how the standard streams should work, so this is 
highly implementation specific. S-Net will try to use the standard 
streams in those nodes of the system where the global input and output
of the program are located at. For this to work correctly, the MPI
implementation must direct the standard streams to thoso nodes.

Note: The network interface with standard I/O has been tested to work 
correctly with MPICH2.

Note: Socket I/O has not been tested to work with distributed S-Net, 
but may do so.


Distributed S-Net and observers
===============================

Observers work with the distributed S-Net as follows:

Observers are always located in the same node than the component that 
they observe. 

If multiple S-Net nodes, that is, MPI processes are located in the same
computer, the observers in these nodes must use different files and/or 
ports to prevent errors on the observer output.


Getting started
===============

1. Prerequisites

   MPI library must be installed. The library must implement the
   MPI standard version 2.1 or greater and must support threading 
   level MPI_THREAD_MULTIPLE. Refer the documentation of your MPI 
   installation for more help. MPICH2 and OpenMPI have been tested 
   to work with distributed S-Net.


2. Setting up the environment

   Set environmental variable MPIROOT to point to your MPI 
   installation. MPI compiler (mpicc) must be found on PATH variable.

     For example:

       export MPIROOT=/home/<your username>/Programs/mpich
       export PATH=$PATH:$MPIROOT/bin:


3. Compile S-Net 
   
   Refer S-Net compilation instructions for this. The S-Net make
   system will use the environmental variable MPIROOT to decide
   if the library (libsnetmpi) for distributed S-Net is built or
   not.


4. Compile the language interface 

   Compile the language interface that you use with your program
   with MPI support. How this is done depends on the language interface. 

     For example: 'C4SNet' interface 
  
       Use command 'make mpi' to compile with MPI support.


5. Compile your program

   First compile the box codes
  
     For example: 'C4SNet' interface 
   
       gcc -I. -I$SNETBASE/include -c *.c

   Then use S-Net compiler with flag '-distributed' to compile your 
   S-Net program. Remember to provide all the needed include and 
   library directories and library names to the S-Net compiler.

     For example:

       snetc -distributed -I$SNETBASE/include -L$SNETBASE/lib myApp.snet 

   If no errors were reported you should now have a working program.    


6. Running the program

   Refer your the documentation of your MPI library for instructions
   how to do this. This is highly MPI implementation specific.

     For example: (MPICH2)

       Start the MPI environment:

         mpd &

       Run the program:

         mpirun -np 32 myApp < myData.xml


Known bugs and issues
=====================
                                                   
1.  If you use observers and run multiple nodes in the same machine, 
    use different ports or files for each node (MPI process). Otherwise 
    the system could get stuck or nothing might be printed.

2.  Non-interactive observers get stuck with MessageAnalyzer for some reason. 
